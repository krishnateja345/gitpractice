-----------------Query to generate the Cricket Match Board------------------

with 
ds1 as      (select TEAM_A teams from cricket
             union all
             select TEAM_B from cricket),
ds2 as      (select teams,count(*) matches_played from ds1
             group by teams),
ds3 as      (select winner,count(*) matches_won from cricket
             group by winner)
select ds2.teams,ds2.matches_played,nvl(ds3.matches_won,0) matches_won,
       (ds2.matches_played-nvl(ds3.matches_won,0)) matches_lost
from ds2 left outer join ds3 on ds2.teams=ds3.winner
order by ds2.teams;

select winner,count(*) matches_won from cricket
group by winner;

---------------------end----------------------------------

-----------------------05-04-2024--------------------------------------

select level from dual
connect by level<=10;


with t1(id) as
(select 1 id from dual
union all
select id+1 from t1
where id<10) select id from t1;

select rownum from
(
select 1 from dual
group by cube(1,2,3)
) where rownum<=5;


select rownum from xmltable('1 to 10');


select str,
       substr(str,level,1) str1,
       substr(str,length(str)+1-level,1) str2,
       substr(str,1,level) str3,
       substr(str,level) str4,
       rpad(' ',level,' ')||substr(str,level) str5,
       rpad(' ',length(str)+1-level,' ')||substr(str,1,level) str6,
       length(str) ln
from(
     select 'WELCOME' str from dual
     )
connect by level<=length(str);

select rpad('tech',7,'*') from dual;

select 'tech' from dual;

-----------------------------------------end------------------------------------

--------------------------------------06-04-2024-----------------------------------------------

with ds1 as
(
select mail_name m from mail_det --where rownum=1
),
ds2 as (select m,
       instr(m,'.',1,1) fdot ,
       instr(m,'.',1,2) sdot,
       instr(m,'@',1) pos
from ds1)
select M, --FDOT, SDOT, POS,
       substr(m,1,fdot-1) first_name,
       substr(m,fdot+1,sdot-fdot-1) middle_name,
       substr(m,sdot+1,pos-sdot-1) Last_name,
       substr(m,pos+1) domain_name
from ds2;

insert into mail_det values('a.b.c@gmail.com');
insert into mail_det values('abc.bc.cdef@gmail.com');
commit;



with ds1 as
(
select mail_name m from mail_det1 --where rownum=1
),
ds2 as (select m,
       --instr(m,'.',1,1) fdot ,
       --instr(m,'.',1,2) sdot,
       instr(m,'@',1) pos
       from ds1),
ds3 as (select M, --FDOT, SDOT, POS, 
       substr(m,1,pos-1) n,
       substr(m,pos+1) d,
       instr(substr(m,1,pos-1),'.',1,1) fdot,
       instr(substr(m,1,pos-1),'.',1,2) sdot
       from ds2)
select M, --N,  FDOT, SDOT,
       /*decode(fdot,0,substr(n,1),substr(n,1,fdot-1)) fname,
       decode(sdot,0,null,substr(n,fdot+1,sdot-fdot)) mname,
       decode(fdot+sdot,0,null,substr(n,sdot)) lname*/
       substr(n,1,decode(fdot,0,length(n),fdot-1)) fname,
       decode(sdot,0,null,substr(n,fdot+1,sdot-fdot-1)) mname,
       decode(fdot+sdot,0,null,substr(n,decode(sdot,0,fdot,sdot)+1)) lname,
       D dname
from ds3;
-------------------------------------------------end----------------------------------------------------
----------------------------07-04-2024--------------------------------------------------------
select empno,ename,sal from emp;
-------------Oracle SQL Practical question with answer calculate the group salary-----
select empno,ename,mgr,
       sys_connect_by_path(ename,'->') lename
from emp
start with mgr is null
connect by prior empno=mgr;


select empno,ename,mgr,sal,
       sys_connect_by_path(ename,'->') lename
from emp
start with ename='BLAKE'
connect by prior empno=mgr;

select empno,ename,sal,(select sum(sal) grpsal
            from emp
            start with ename=a.ename
            connect by prior empno=mgr) grpsal
from emp a;

-------------inline view to find the emp sal greater than avg salary------------------
select empno,ename,sal,a.deptno from emp a,
       (select b.deptno,avg(b.sal) avgsal from emp b 
        group by b.deptno
        ) c
where a.deptno=c.deptno and a.sal>c.avgsal;

----------------corelated query to find the emp sal greater than avg salary----------------
select a.empno,a.ename,a.sal,a.deptno from emp a
where sal>(select avg(sal) from emp b
           where b.deptno=a.deptno
           group by b.deptno);



--select * from students;

select DEPT, --CNT, RES, 
       max(case when year=1 then res end) I_year,
       max(case when year=2 then res end) II_year,
       max(case when year=3 then res end) III_year,
       max(case when year=4 then res end) IV_year
from 
            (
            select dept,year,count(result) cnt,
                   'P='||count(case when result='P' then result else null end)||
                   ',F='||count(case when result='F' then result else null end) res
            from students
            group by dept,year)
group by dept;




--select * from students;

select year, --CNT, RES, 
       max(case when dept='EEE' then res end) EEE,
       max(case when dept='CSE' then res end) CSE,
       max(case when dept='CVE' then res end) CVE,
       max(case when dept='MECH' then res end) MECH,
	   max(case when dept='ECE' then res end) ECE
	   
from 
            (
            select dept,year,count(result) cnt,
                   'P='||count(case when result='P' then result else null end)||
                   ',F='||count(case when result='F' then result else null end) res
            from students
            group by dept,year)
group by year;






-----using pivot-----------

select * from
(
select dept,year,--count(result) cnt,
                   'P='||count(case when result='P' then result else null end)||
                   ',F='||count(case when result='F' then result else null end) res
            from students
            group by dept,year
            order by year)
pivot(max(res) for dept in('EEE','ECE','CSE','CVE','MECH'))
order by year;

select * from
(
select dept,year,--count(result) cnt,
                   'P='||count(case when result='P' then result else null end)||
                   ',F='||count(case when result='F' then result else null end) res
            from students
            group by dept,year
            order by year)
pivot(max(res) for year in(1 as I_year,2 as II_year,3 as III_year,4 as IV_year))
order by dept;
-------------------------------------------end----------------------------------------------------

-----------------------08-04-2024  ------------------------------------------------------------

-----------------------------Qwery to find all possible paths for a given cities-----------------------------
select --a.CITY_ID, 
       a.CITY_NAME, 
       --b.CITY_ID city_id2, 
       b.CITY_NAME CITY_NAME2
from cities a,cities b
where a.city_id<b.city_id;


select --a.CITY_NAME, 
       --b.CITY_NAME CITY_NAME2,
       distinct greatest(a.CITY_NAME,b.CITY_NAME) city1,
       least(a.CITY_NAME,b.CITY_NAME) city2
from cities a,cities b
where a.city_id<>b.city_id;



---------------query to get list of persons working under each employee------

--------------query with inline view in the from clause----------------
select empno,ename,mgr from emp;


select mgr,
       listagg(ename,',') within group(order by ename) emps_list,
       count(*) emps_cnt
from emp
group by mgr
order by mgr;


select empno,
       ename,
       a.mgr,
       nvl(b.emps_list,0) emps_list,
       nvl(b.emps_cnt,0) emps_cnt
from emp a left outer join
         (select mgr,
          listagg(ename,',') within group(order by ename) emps_list,
          count(*) emps_cnt
          from emp
          group by mgr
          order by mgr)b
on a.empno=b.mgr
order by empno;

--------------query with inline view in the select clause----------------

select empno,ename from emp;


select listagg(ename,',') within group(order by ename) emps_list
from emp
where mgr=7566;

select empno,ename,(select listagg(ename,',') within group(order by ename) 
                    from emp
                    where mgr=e.empno) emps_list,
                    (select count(*)
                    from emp
                    where mgr=e.empno) emps_cnt
from emp e
order by empno;


--------------self join--------------
select m.empno,m.ename,
       listagg(e.ename,',') within group(order by e.ename) emp_list,
       count(e.ename) emps_cnt
from emp m left outer join emp e on m.empno=e.mgr
group by m.empno,m.ename
order by m.empno;
-----------------------------end----------------------------------------------

------------------------------------------10-04-2024-----------------------------------------

------------------------ SQL to generate all the date range for the transaction records-------------


select * from HR.tran_amount;


create table tran_data
(
tran_date date,
tran_desc varchar2(20),
tran_amount number
);


insert into tran_data values('05-may-24','Bill Payment',1000);
insert into tran_data values('07-may-24','Deposit',5000);
insert into tran_data values('09-may-24','Fees Payment',2500);
insert into tran_data values('12-may-24','Bonus Recevied',3400);
insert into tran_data values('13-may-24','Bonus Recevied',3400);
commit;


with ds1 as (
            select min(tran_date) mindate, max(tran_date) maxdate
            from tran_data
            ),
     ds2 as (select trunc(mindate,'MM') sdate,last_day(maxdate) ldate,
            last_day(maxdate)-trunc(mindate,'MM')+1 ndays
            from ds1),
     ds3 as (select sdate+level-1 tdate from ds2
            connect by level<=ndays)
select TDATE, TRAN_DESC, nvl(TRAN_AMOUNT,0) TRAN_AMOUNT from ds3 
left outer join tran_data on tran_data.tran_date=ds3.tdate
order by ds3.tdate;

select * from tran_data;

-------testing--------------
insert into tran_data values('23-may-24','UPI Payment',7200);

insert into tran_data values('12-june-24','Rent Payment',12000);

insert into tran_data values('12-jan-24','Fees Payment',10000);

commit;

-------------------------------------SQL to Find number of saturday and sunday----------------------------

with ds1 as
            (
            select trunc(sysdate,'Month') fdate,
                   last_day(sysdate) ldate,
                   (last_day(trunc(sysdate))-trunc(sysdate,'Month')) ndays
            from dual
            ),
     ds2 as (select fdate+level-1 tdate,
             trim(to_char(fdate+level-1,'DAY')) D_ay
             from ds1
             connect by level<=ndays
             )
select d_ay,count(*) cnt from ds2
where d_ay='SUNDAY' or d_ay='SATURDAY'
group by d_ay;


--------testing the queries with different dates----------------
with ds1 as
            (
            select trunc(to_date('10-05-24'),'Month') fdate,
                   last_day(to_date('10-05-24')) ldate,
                   round(last_day(to_date('10-05-24'))-trunc(to_date('10-05-24'),'Month')) ndays
            from dual
            ),
     ds2 as (select fdate+level-1 tdate,
             trim(to_char(fdate+level-1,'DAY')) D_ay
             from ds1
             connect by level<=ndays+1
             )
select d_ay,count(*) cnt from ds2
where d_ay='SUNDAY' or d_ay='SATURDAY'
group by d_ay;


with ds1 as
            (
            select trunc(to_date('11-11-24'),'Month') fdate,
                   last_day(to_date('11-11-24')) ldate,
                   round(last_day(to_date('11-11-24'))-trunc(to_date('11-11-24'),'Month')) ndays
            from dual
            ),
     ds2 as (select fdate+level-1 tdate,
             trim(to_char(fdate+level-1,'DAY')) D_ay
             from ds1
             connect by level<=ndays+1
             )
select d_ay,count(*) cnt from ds2
where d_ay='SUNDAY' or d_ay='SATURDAY'
group by d_ay;


------------------------end--------------------------------------------------------


--------------------------------11-04-2024------------------------------------------
---------Oracle SQL Practical question with answer Write a SQL to print Cricket Dashboard
--------performace point of view----------------
with ds as
        (
        select team_a a,team_b b,
                case when team_a=winner then 1 else 0 end t_a,
                case when team_b=winner then 1 else 0 end t_b
        from cricket)
select teams,
       count(*) matches_played,
       sum(teams_cnt) matches_won,
       count(*)-sum(teams_cnt) matches_lost
from
                    (
                    select --a,b,t_a,t_b ,r,
                           decode(r,1,a,b) teams,
                           decode(r,1,t_a,t_b) teams_cnt
                    from ds,(select rownum r from dual connect by level<=2)
                    )
group by teams;


--------Oracle SQL Practical question with answer | SQL to find list of DICE rolled combinations

with t as
        (
        select level n from dual
        connect by level<=6
        )
select '('||t1.n||','||t2.n||','||t3.n||')' res from t t1,t t2, t t3
where t3.n=t1.n+t2.n;


with t as
        (
        select level n from dual
        connect by level<=6
        )
select '('||t1.n||','||t2.n||','||t3.n||')' res from t t1,t t2, t t3
where t3.n=t1.n+t2.n or t2.n=t1.n+t3.n or t1.n=t2.n+t3.n;

----------------end----------------------------------------------------------------------------------


---------------------12-04-2024--------------

-------------sort the numbers in the comma separated list--------
with ds as(  
           select '3,10,5,1,7,55,75,100,42,12,17' str from dual
           )
select --str,
       listagg(regexp_substr(str,'[^,]+',1,level),',')
       within group(order by regexp_substr(str,'[^,]+',1,level))  rstr
from ds
connect by level<=regexp_count(str,',')+1;

-----converting result string using to_number in order sort the data as it is in
-----string format
with ds as(  
           select '3,10,5,1,7,55,75,100,42,12,17' str from dual
           )
select --str,
       listagg(regexp_substr(str,'[^,]+',1,level),',')
       within group(order by to_number(regexp_substr(str,'[^,]+',1,level)))  rstr
from ds
connect by level<=regexp_count(str,',')+1;


with ds as(
            select 'WELCOME' str
            from dual
            ),
ds2 as (select str,
       substr(str,level,1) str1
from ds
connect by level<=length(str))
select listagg(str1) within group(order by str1) rstr from ds2;


---------Oracle SQL Practical question with answer | Reverse the String without using reverse function

with ds as(
            select 'WELCOME' str
            from dual
            )
select str,reverse(str) rstr from ds;


with ds as(
            select 'WELCOME' str
            from dual
            ),
ds2 as (select str,level l,
       substr(str,level,1) str1
       from ds
connect by level<=length(str))
select listagg(str1) within group(order by l desc) rstr from ds2;---reversing the string  by doing order 
----by level desc
-----------------end-------------------------------------------------------------------------------------

----------------------15-04-2024-------------------------------------------------
---------------consolidate two rows as a single row--------------------------

with ds as(
            select empno,ename,
                   rownum rn,
                   count(*) over() cnt,
                   round(count(*) over()/2) cnt1,
                   (round(count(*) over()/2)-rownum) acnt
            from emp_a),
 ds1 as (select * from ds where acnt>=0),
 ds2 as (select * from ds where acnt<0)
 select --ds1.empno,
        ds1.ename,
        --ds2.empno,
        ds2.ename from ds1 
 left outer join ds2 on ds1.acnt=abs(ds2.acnt)
 order by ds1.empno;
 
 
 select * from emp_b;
 
 delete from emp_b;
 
 
 insert into emp_b (empno1,ename1,empno2,ename2)
 with ds as(
            select empno,ename,
                   rownum rn,
                   count(*) over() cnt,
                   round(count(*) over()/2) cnt1,
                   (round(count(*) over()/2)-rownum) acnt
            from emp_a),
 ds1 as (select * from ds where acnt>=0),
 ds2 as (select * from ds where acnt<0)
 select ds1.empno,
        ds1.ename,
        ds2.empno,
        ds2.ename from ds1 
 left outer join ds2 on ds1.acnt=abs(ds2.acnt)
 order by ds1.empno;
 
 
 select * from emp_b;
 
 
 
  ------Oracle SQL Practical question with answer Fill the missing dates with last not null value

create table txn_data
(
txn_date date,
txn_amount number
);

insert into txn_data values('20-jul-24',100);
insert into txn_data values('25-jul-24',200);
insert into txn_data values('30-jul-24',300);
commit;

with ds as(
            select min(txn_date) mndate,
                   max(txn_date) mxdate,
                   max(txn_date)-min(txn_date) ndays
            from txn_data),
ds1 as (select mndate+level-1 txn_date from ds connect by level<=ndays+1)
select ds1.txn_date,--txn_data.txn_amount,
       decode(txn_amount,null,last_value(txn_data.txn_amount ignore nulls) over(order by ds1.txn_date),
       txn_data.txn_amount) act_result
from ds1 left outer join txn_data on ds1.txn_date=txn_data.txn_date
order by ds1.txn_date;
-----------------------end----------------------------------------------------------------

-------------------16-04-2024---------------
----Oracle SQL Practical question with answer | Compute the start and end value of group in given seq
with ds as
        (
        select id,id-rownum grp_value from ranges
        )
select min(id) start_range,max(id) end_range from ds
group by grp_value
order by 1;

-----------------Oracle SQL Practical question with answer Expand the range to Sequence Numbers

with ds1 as
            (
            select start_range,end_range from ranges_1
            ),
 ds2 as (select max(end_range) mr from ranges_1),
 ds3 as (select level l from ds2
 connect by level<=mr)
 select l from ds3,ds1 where l>=ds1.start_range and l<=ds1.end_range;
 
 ------------query ran on oracle livesql
 create table ranges_1
(
    start_range int,
    end_range int
);

/*insert into ranges_1 values(1,3);
insert into ranges_1 values(5,5);
insert into ranges_1 values(7,9);
insert into ranges_1 values(11,12);
insert into ranges_1 values(15,16);
insert into ranges_1 values(20,20);
commit;*/

delete from ranges_1;

select --start_range,end_range,
    --end_range-start_range+1 n,
    start_range+l-1 result
    from ranges_1,lateral(select level l from dual connect by level<=end_range-start_range+1);
 
 
 -----------------end---------------------------------