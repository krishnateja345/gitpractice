-----------------Query to generate the Cricket Match Board------------------

with 
ds1 as      (select TEAM_A teams from cricket
             union all
             select TEAM_B from cricket),
ds2 as      (select teams,count(*) matches_played from ds1
             group by teams),
ds3 as      (select winner,count(*) matches_won from cricket
             group by winner)
select ds2.teams,ds2.matches_played,nvl(ds3.matches_won,0) matches_won,
       (ds2.matches_played-nvl(ds3.matches_won,0)) matches_lost
from ds2 left outer join ds3 on ds2.teams=ds3.winner
order by ds2.teams;

select winner,count(*) matches_won from cricket
group by winner;

---------------------end----------------------------------

-----------------------05-04-2024--------------------------------------

select level from dual
connect by level<=10;


with t1(id) as
(select 1 id from dual
union all
select id+1 from t1
where id<10) select id from t1;

select rownum from
(
select 1 from dual
group by cube(1,2,3)
) where rownum<=5;


select rownum from xmltable('1 to 10');


select str,
       substr(str,level,1) str1,
       substr(str,length(str)+1-level,1) str2,
       substr(str,1,level) str3,
       substr(str,level) str4,
       rpad(' ',level,' ')||substr(str,level) str5,
       rpad(' ',length(str)+1-level,' ')||substr(str,1,level) str6,
       length(str) ln
from(
     select 'WELCOME' str from dual
     )
connect by level<=length(str);

select rpad('tech',7,'*') from dual;

select 'tech' from dual;

-----------------------------------------end------------------------------------

--------------------------------------06-04-2024-----------------------------------------------

with ds1 as
(
select mail_name m from mail_det --where rownum=1
),
ds2 as (select m,
       instr(m,'.',1,1) fdot ,
       instr(m,'.',1,2) sdot,
       instr(m,'@',1) pos
from ds1)
select M, --FDOT, SDOT, POS,
       substr(m,1,fdot-1) first_name,
       substr(m,fdot+1,sdot-fdot-1) middle_name,
       substr(m,sdot+1,pos-sdot-1) Last_name,
       substr(m,pos+1) domain_name
from ds2;

insert into mail_det values('a.b.c@gmail.com');
insert into mail_det values('abc.bc.cdef@gmail.com');
commit;



with ds1 as
(
select mail_name m from mail_det1 --where rownum=1
),
ds2 as (select m,
       --instr(m,'.',1,1) fdot ,
       --instr(m,'.',1,2) sdot,
       instr(m,'@',1) pos
       from ds1),
ds3 as (select M, --FDOT, SDOT, POS, 
       substr(m,1,pos-1) n,
       substr(m,pos+1) d,
       instr(substr(m,1,pos-1),'.',1,1) fdot,
       instr(substr(m,1,pos-1),'.',1,2) sdot
       from ds2)
select M, --N,  FDOT, SDOT,
       /*decode(fdot,0,substr(n,1),substr(n,1,fdot-1)) fname,
       decode(sdot,0,null,substr(n,fdot+1,sdot-fdot)) mname,
       decode(fdot+sdot,0,null,substr(n,sdot)) lname*/
       substr(n,1,decode(fdot,0,length(n),fdot-1)) fname,
       decode(sdot,0,null,substr(n,fdot+1,sdot-fdot-1)) mname,
       decode(fdot+sdot,0,null,substr(n,decode(sdot,0,fdot,sdot)+1)) lname,
       D dname
from ds3;
-------------------------------------------------end----------------------------------------------------
----------------------------07-04-2024--------------------------------------------------------
select empno,ename,sal from emp;
-------------Oracle SQL Practical question with answer calculate the group salary-----
select empno,ename,mgr,
       sys_connect_by_path(ename,'->') lename
from emp
start with mgr is null
connect by prior empno=mgr;


select empno,ename,mgr,sal,
       sys_connect_by_path(ename,'->') lename
from emp
start with ename='BLAKE'
connect by prior empno=mgr;

select empno,ename,sal,(select sum(sal) grpsal
            from emp
            start with ename=a.ename
            connect by prior empno=mgr) grpsal
from emp a;

-------------inline view to find the emp sal greater than avg salary------------------
select empno,ename,sal,a.deptno from emp a,
       (select b.deptno,avg(b.sal) avgsal from emp b 
        group by b.deptno
        ) c
where a.deptno=c.deptno and a.sal>c.avgsal;

----------------corelated query to find the emp sal greater than avg salary----------------
select a.empno,a.ename,a.sal,a.deptno from emp a
where sal>(select avg(sal) from emp b
           where b.deptno=a.deptno
           group by b.deptno);



--select * from students;

select DEPT, --CNT, RES, 
       max(case when year=1 then res end) I_year,
       max(case when year=2 then res end) II_year,
       max(case when year=3 then res end) III_year,
       max(case when year=4 then res end) IV_year
from 
            (
            select dept,year,count(result) cnt,
                   'P='||count(case when result='P' then result else null end)||
                   ',F='||count(case when result='F' then result else null end) res
            from students
            group by dept,year)
group by dept;




--select * from students;

select year, --CNT, RES, 
       max(case when dept='EEE' then res end) EEE,
       max(case when dept='CSE' then res end) CSE,
       max(case when dept='CVE' then res end) CVE,
       max(case when dept='MECH' then res end) MECH,
	   max(case when dept='ECE' then res end) ECE
	   
from 
            (
            select dept,year,count(result) cnt,
                   'P='||count(case when result='P' then result else null end)||
                   ',F='||count(case when result='F' then result else null end) res
            from students
            group by dept,year)
group by year;






-----using pivot-----------

select * from
(
select dept,year,--count(result) cnt,
                   'P='||count(case when result='P' then result else null end)||
                   ',F='||count(case when result='F' then result else null end) res
            from students
            group by dept,year
            order by year)
pivot(max(res) for dept in('EEE','ECE','CSE','CVE','MECH'))
order by year;

select * from
(
select dept,year,--count(result) cnt,
                   'P='||count(case when result='P' then result else null end)||
                   ',F='||count(case when result='F' then result else null end) res
            from students
            group by dept,year
            order by year)
pivot(max(res) for year in(1 as I_year,2 as II_year,3 as III_year,4 as IV_year))
order by dept;
-------------------------------------------end----------------------------------------------------

-----------------------08-04-2024  ------------------------------------------------------------

-----------------------------Qwery to find all possible paths for a given cities-----------------------------
select --a.CITY_ID, 
       a.CITY_NAME, 
       --b.CITY_ID city_id2, 
       b.CITY_NAME CITY_NAME2
from cities a,cities b
where a.city_id<b.city_id;


select --a.CITY_NAME, 
       --b.CITY_NAME CITY_NAME2,
       distinct greatest(a.CITY_NAME,b.CITY_NAME) city1,
       least(a.CITY_NAME,b.CITY_NAME) city2
from cities a,cities b
where a.city_id<>b.city_id;



---------------query to get list of persons working under each employee------

--------------query with inline view in the from clause----------------
select empno,ename,mgr from emp;


select mgr,
       listagg(ename,',') within group(order by ename) emps_list,
       count(*) emps_cnt
from emp
group by mgr
order by mgr;


select empno,
       ename,
       a.mgr,
       nvl(b.emps_list,0) emps_list,
       nvl(b.emps_cnt,0) emps_cnt
from emp a left outer join
         (select mgr,
          listagg(ename,',') within group(order by ename) emps_list,
          count(*) emps_cnt
          from emp
          group by mgr
          order by mgr)b
on a.empno=b.mgr
order by empno;

--------------query with inline view in the select clause----------------

select empno,ename from emp;


select listagg(ename,',') within group(order by ename) emps_list
from emp
where mgr=7566;

select empno,ename,(select listagg(ename,',') within group(order by ename) 
                    from emp
                    where mgr=e.empno) emps_list,
                    (select count(*)
                    from emp
                    where mgr=e.empno) emps_cnt
from emp e
order by empno;


--------------self join--------------
select m.empno,m.ename,
       listagg(e.ename,',') within group(order by e.ename) emp_list,
       count(e.ename) emps_cnt
from emp m left outer join emp e on m.empno=e.mgr
group by m.empno,m.ename
order by m.empno;
-----------------------------end----------------------------------------------

------------------------------------------10-04-2024-----------------------------------------

------------------------ SQL to generate all the date range for the transaction records-------------


select * from HR.tran_amount;


create table tran_data
(
tran_date date,
tran_desc varchar2(20),
tran_amount number
);


insert into tran_data values('05-may-24','Bill Payment',1000);
insert into tran_data values('07-may-24','Deposit',5000);
insert into tran_data values('09-may-24','Fees Payment',2500);
insert into tran_data values('12-may-24','Bonus Recevied',3400);
insert into tran_data values('13-may-24','Bonus Recevied',3400);
commit;


with ds1 as (
            select min(tran_date) mindate, max(tran_date) maxdate
            from tran_data
            ),
     ds2 as (select trunc(mindate,'MM') sdate,last_day(maxdate) ldate,
            last_day(maxdate)-trunc(mindate,'MM')+1 ndays
            from ds1),
     ds3 as (select sdate+level-1 tdate from ds2
            connect by level<=ndays)
select TDATE, TRAN_DESC, nvl(TRAN_AMOUNT,0) TRAN_AMOUNT from ds3 
left outer join tran_data on tran_data.tran_date=ds3.tdate
order by ds3.tdate;

select * from tran_data;

-------testing--------------
insert into tran_data values('23-may-24','UPI Payment',7200);

insert into tran_data values('12-june-24','Rent Payment',12000);

insert into tran_data values('12-jan-24','Fees Payment',10000);

commit;

-------------------------------------SQL to Find number of saturday and sunday----------------------------

with ds1 as
            (
            select trunc(sysdate,'Month') fdate,
                   last_day(sysdate) ldate,
                   (last_day(trunc(sysdate))-trunc(sysdate,'Month')) ndays
            from dual
            ),
     ds2 as (select fdate+level-1 tdate,
             trim(to_char(fdate+level-1,'DAY')) D_ay
             from ds1
             connect by level<=ndays
             )
select d_ay,count(*) cnt from ds2
where d_ay='SUNDAY' or d_ay='SATURDAY'
group by d_ay;


--------testing the queries with different dates----------------
with ds1 as
            (
            select trunc(to_date('10-05-24'),'Month') fdate,
                   last_day(to_date('10-05-24')) ldate,
                   round(last_day(to_date('10-05-24'))-trunc(to_date('10-05-24'),'Month')) ndays
            from dual
            ),
     ds2 as (select fdate+level-1 tdate,
             trim(to_char(fdate+level-1,'DAY')) D_ay
             from ds1
             connect by level<=ndays+1
             )
select d_ay,count(*) cnt from ds2
where d_ay='SUNDAY' or d_ay='SATURDAY'
group by d_ay;


with ds1 as
            (
            select trunc(to_date('11-11-24'),'Month') fdate,
                   last_day(to_date('11-11-24')) ldate,
                   round(last_day(to_date('11-11-24'))-trunc(to_date('11-11-24'),'Month')) ndays
            from dual
            ),
     ds2 as (select fdate+level-1 tdate,
             trim(to_char(fdate+level-1,'DAY')) D_ay
             from ds1
             connect by level<=ndays+1
             )
select d_ay,count(*) cnt from ds2
where d_ay='SUNDAY' or d_ay='SATURDAY'
group by d_ay;


------------------------end--------------------------------------------------------


--------------------------------11-04-2024------------------------------------------
---------Oracle SQL Practical question with answer Write a SQL to print Cricket Dashboard
--------performace point of view----------------
with ds as
        (
        select team_a a,team_b b,
                case when team_a=winner then 1 else 0 end t_a,
                case when team_b=winner then 1 else 0 end t_b
        from cricket)
select teams,
       count(*) matches_played,
       sum(teams_cnt) matches_won,
       count(*)-sum(teams_cnt) matches_lost
from
                    (
                    select --a,b,t_a,t_b ,r,
                           decode(r,1,a,b) teams,
                           decode(r,1,t_a,t_b) teams_cnt
                    from ds,(select rownum r from dual connect by level<=2)
                    )
group by teams;


--------Oracle SQL Practical question with answer | SQL to find list of DICE rolled combinations

with t as
        (
        select level n from dual
        connect by level<=6
        )
select '('||t1.n||','||t2.n||','||t3.n||')' res from t t1,t t2, t t3
where t3.n=t1.n+t2.n;


with t as
        (
        select level n from dual
        connect by level<=6
        )
select '('||t1.n||','||t2.n||','||t3.n||')' res from t t1,t t2, t t3
where t3.n=t1.n+t2.n or t2.n=t1.n+t3.n or t1.n=t2.n+t3.n;

----------------end----------------------------------------------------------------------------------


---------------------12-04-2024--------------

-------------sort the numbers in the comma separated list--------
with ds as(  
           select '3,10,5,1,7,55,75,100,42,12,17' str from dual
           )
select --str,
       listagg(regexp_substr(str,'[^,]+',1,level),',')
       within group(order by regexp_substr(str,'[^,]+',1,level))  rstr
from ds
connect by level<=regexp_count(str,',')+1;

-----converting result string using to_number in order sort the data as it is in
-----string format
with ds as(  
           select '3,10,5,1,7,55,75,100,42,12,17' str from dual
           )
select --str,
       listagg(regexp_substr(str,'[^,]+',1,level),',')
       within group(order by to_number(regexp_substr(str,'[^,]+',1,level)))  rstr
from ds
connect by level<=regexp_count(str,',')+1;


with ds as(
            select 'WELCOME' str
            from dual
            ),
ds2 as (select str,
       substr(str,level,1) str1
from ds
connect by level<=length(str))
select listagg(str1) within group(order by str1) rstr from ds2;


---------Oracle SQL Practical question with answer | Reverse the String without using reverse function

with ds as(
            select 'WELCOME' str
            from dual
            )
select str,reverse(str) rstr from ds;


with ds as(
            select 'WELCOME' str
            from dual
            ),
ds2 as (select str,level l,
       substr(str,level,1) str1
       from ds
connect by level<=length(str))
select listagg(str1) within group(order by l desc) rstr from ds2;---reversing the string  by doing order 
----by level desc
-----------------end-------------------------------------------------------------------------------------

----------------------15-04-2024-------------------------------------------------
---------------consolidate two rows as a single row--------------------------

with ds as(
            select empno,ename,
                   rownum rn,
                   count(*) over() cnt,
                   round(count(*) over()/2) cnt1,
                   (round(count(*) over()/2)-rownum) acnt
            from emp_a),
 ds1 as (select * from ds where acnt>=0),
 ds2 as (select * from ds where acnt<0)
 select --ds1.empno,
        ds1.ename,
        --ds2.empno,
        ds2.ename from ds1 
 left outer join ds2 on ds1.acnt=abs(ds2.acnt)
 order by ds1.empno;
 
 
 select * from emp_b;
 
 delete from emp_b;
 
 
 insert into emp_b (empno1,ename1,empno2,ename2)
 with ds as(
            select empno,ename,
                   rownum rn,
                   count(*) over() cnt,
                   round(count(*) over()/2) cnt1,
                   (round(count(*) over()/2)-rownum) acnt
            from emp_a),
 ds1 as (select * from ds where acnt>=0),
 ds2 as (select * from ds where acnt<0)
 select ds1.empno,
        ds1.ename,
        ds2.empno,
        ds2.ename from ds1 
 left outer join ds2 on ds1.acnt=abs(ds2.acnt)
 order by ds1.empno;
 
 
 select * from emp_b;
 
 
 
  ------Oracle SQL Practical question with answer Fill the missing dates with last not null value

create table txn_data
(
txn_date date,
txn_amount number
);

insert into txn_data values('20-jul-24',100);
insert into txn_data values('25-jul-24',200);
insert into txn_data values('30-jul-24',300);
commit;

with ds as(
            select min(txn_date) mndate,
                   max(txn_date) mxdate,
                   max(txn_date)-min(txn_date) ndays
            from txn_data),
ds1 as (select mndate+level-1 txn_date from ds connect by level<=ndays+1)
select ds1.txn_date,--txn_data.txn_amount,
       decode(txn_amount,null,last_value(txn_data.txn_amount ignore nulls) over(order by ds1.txn_date),
       txn_data.txn_amount) act_result
from ds1 left outer join txn_data on ds1.txn_date=txn_data.txn_date
order by ds1.txn_date;
-----------------------end----------------------------------------------------------------

-------------------16-04-2024---------------
----Oracle SQL Practical question with answer | Compute the start and end value of group in given seq
with ds as
        (
        select id,id-rownum grp_value from ranges
        )
select min(id) start_range,max(id) end_range from ds
group by grp_value
order by 1;

-----------------Oracle SQL Practical question with answer Expand the range to Sequence Numbers

with ds1 as
            (
            select start_range,end_range from ranges_1
            ),
 ds2 as (select max(end_range) mr from ranges_1),
 ds3 as (select level l from ds2
 connect by level<=mr)
 select l from ds3,ds1 where l>=ds1.start_range and l<=ds1.end_range;
 
 ------------query ran on oracle livesql
 create table ranges_1
(
    start_range int,
    end_range int
);

/*insert into ranges_1 values(1,3);
insert into ranges_1 values(5,5);
insert into ranges_1 values(7,9);
insert into ranges_1 values(11,12);
insert into ranges_1 values(15,16);
insert into ranges_1 values(20,20);
commit;*/

delete from ranges_1;

select --start_range,end_range,
    --end_range-start_range+1 n,
    start_range+l-1 result
    from ranges_1,lateral(select level l from dual connect by level<=end_range-start_range+1);
 
 
 -----------------end---------------------------------

 -----------------17-04-2024-------------------------------------
 --------Oracle SQL Practical question with answer Grouping The Range Data

create table car_years
(
	name varchar2(20),
    start_year number,
    end_year number
    
);

/*insert into car_years values('Swift',2007,2009);
insert into car_years values('Swift',2009,2011);
insert into car_years values('Swift',2011,2013);
insert into car_years values('Maruthi',2009,2011);
insert into car_years values('Maruthi',2013,2015);
commit;*/

select name,min(year) startyear,max(year) endyear --year-rownum 
    from
    (
    select distinct name,--start_year,end_year,
        --end_year-start_year nyrs,
        --l,
        start_year+l-1 year
        from car_years,lateral(select level l from dual connect by level<=end_year-start_year+1)
    order by name,year
    )
    group by name,year-rownum;


    -------------Oracle SQL Practical question with answer / SQL to check whether given sudoku is resolved


select  case when sum( distinct rsum)=45 then 'Sudoku is valid' else
                                              'Sudoku is invalid' end Result
from
(select row_no, C1+ C2+ C3+ C4+ C5+ C6+ C7+ C8+ C9 rsum from sudoku
union all
select col_name col_no,col_value csum from
(
select sum(C1) C1, sum(C2) C2, sum(C3) C3, sum(C4) C4, sum(C5) C5,
sum(C6) C6, sum(C7) C7, sum(C8) C8, sum(C9) C9
from sudoku) unpivot(col_value for col_name in (C1,C2,C3,C4,C5,C6,C7,C8,C9))
union all
select grp||col_name grp_no,col_value grpsum from 
(
select 'G'||ceil(rownum/3) grp,
        sum(C1+ C2+ C3) G1, sum(C4+ C5+ C6) G2, sum(C7+ C8+ C9) G3
        from sudoku
group by ceil(rownum/3)) unpivot(col_value for col_name in(G1,G2,G3))
);
-----to list the grpnames colname rowname------------
select 
rsum,
listagg(row_no,',') within group(order by row_no) grp_names,
case when sum( distinct rsum)=45 then 'Sudoku is valid' else
                                              'Sudoku is invalid' end Result
from
(select row_no, C1+ C2+ C3+ C4+ C5+ C6+ C7+ C8+ C9 rsum from sudoku
union all
select col_name col_no,col_value csum from
(
select sum(C1) C1, sum(C2) C2, sum(C3) C3, sum(C4) C4, sum(C5) C5,
sum(C6) C6, sum(C7) C7, sum(C8) C8, sum(C9) C9
from sudoku) unpivot(col_value for col_name in (C1,C2,C3,C4,C5,C6,C7,C8,C9))
union all
select grp||col_name grp_no,col_value grpsum from 
(
select 'G'||ceil(rownum/3) grp,
        sum(C1+ C2+ C3) G1, sum(C4+ C5+ C6) G2, sum(C7+ C8+ C9) G3
        from sudoku
group by ceil(rownum/3)) unpivot(col_value for col_name in(G1,G2,G3))
)
group by rsum;

-------update sudoku set c3=5 where row_no='R3';

----------------------------------------end--------------------------------

----------19-04-2024----------------
----Oracle SQL Practical question with answer | SQL to convert list of numbers into table format
----data in x axis
select c1,c2,c3,c4,c5 from 
(
select n,
--n/5,
ceil((n/5)) x,
row_number() over(partition by ceil(n/5) order by n) y
from  
(
select level n from dual
connect by level<=25
)) pivot (sum(n) for y in(1 c1,2 c2,3 c3,4 c4,5 c5)) order by 1;

----data in y -axis

select c1,c2,c3,c4,c5 from 
(
select n,
--n/5,
ceil((n/5)) x,
row_number() over(partition by ceil(n/5) order by n) y
from  
(
select level n from dual
connect by level<=25
)) pivot (sum(n) for x in(1 c1,2 c2,3 c3,4 c4,5 c5)) order by 1;

-----using Mod
select --n,
       --ceil(n/5),--mod(n,5),
       max(case when mod(n,5)=1 then n end) c1,
       max(case when mod(n,5)=2 then n end) c2,
       max(case when mod(n,5)=3 then n end) c3,
       max(case when mod(n,5)=4 then n end) c4,
       max(case when mod(n,5)=0 then n end) c5
from (
select level n from dual
connect by level<=25
) group by ceil(n/5)
order by 1;


-----------------Oracle SQL Practical question | SQL to fetch Emp hierarchical data in Flat format
select l4.*,
       l5.EMPNO lv5empno, l5.ENAME lv5ename, case when l5.empno is  not null then 5 end lv5       
from 
(
select 
       l3.*,
       l4.EMPNO lv4empno, l4.ENAME lv4ename, case when l4.empno is  not null then 4 end lv4
from
(
select 
       l2.*,
       l3.EMPNO lv3empno, l3.ENAME lv3ename, 3 lv3
from (
select l1.EMPNO lv1empno, l1.ENAME lv1ename, 1 lv1, 
       l2.EMPNO lv2empno, l2.ENAME lv2ename, 2 lv2 from 
(
select empno,ename from emp
where mgr is null) l1
left outer join emp l2 on l2.mgr=l1.empno) l2
left outer join emp l3 on l3.mgr=l2.lv2empno) l3
left outer join emp l4 on l4.mgr=l3.lv3empno) l4
left outer join emp l5 on l5.mgr=l4.lv4empno
order by 1,4;


----using another method-------

select --empno_list,
       --ename_list,
       regexp_substr(empno_list,'\w+',1,1) lv1empno, regexp_substr(ename_list,'\w+',1,1) lvename,1 lv1,
       regexp_substr(empno_list,'\w+',1,2) lv1empno, regexp_substr(ename_list,'\w+',1,2) lvename,2 lv2,
       regexp_substr(empno_list,'\w+',1,3) lv1empno, regexp_substr(ename_list,'\w+',1,3) lvename,3 lv3,
       regexp_substr(empno_list,'\w+',1,4) lv1empno, regexp_substr(ename_list,'\w+',1,4) lvename,
       case when regexp_substr(empno_list,'\w+',1,4) is not null then 4 end lv4,
       regexp_substr(empno_list,'\w+',1,5) lv1empno, regexp_substr(ename_list,'\w+',1,5) lvename,
       case when regexp_substr(empno_list,'\w+',1,5) is not null then 5 end lv5
from 
(
select trim(',' from sys_connect_by_path(empno,',')) empno_list,
       trim(',' from sys_connect_by_path(ename,',')) ename_list,
       CONNECT_BY_ISLEAF is_leaf
from emp
start with mgr is null
connect by prior empno=mgr)
where is_leaf=1;
---------end--------------------------------

----------------------25-04-2024----------------------
---Oracle SQL Practical question | SQL to group the employees into multiple team
---2 members each team
with ds as 
        (
        select ename,city,
               row_number() over(partition by city order by rownum ) seqno,
               ceil(row_number() over(partition by city order by rownum ) /2) grpno
        from emp_city)
select listagg(ename,',') within group(order by ename) ename_list,
       city,
       --grpno,
       'Team -'||row_number() over(order by city) team_no
       from ds
group by city,grpno;

----3 members each team

with ds as 
        (
        select ename,city,
               row_number() over(partition by city order by rownum ) seqno,
               ceil(row_number() over(partition by city order by rownum ) /3) grpno
        from emp_city)
select listagg(ename,',') within group(order by ename) ename_list,
       city,
       --grpno,
       'Team -'||row_number() over(order by city) team_no
       from ds
group by city,grpno;

----4 memebers each team
with ds as 
        (
        select ename,city,
               row_number() over(partition by city order by rownum ) seqno,
               ceil(row_number() over(partition by city order by rownum ) /4) grpno
        from emp_city)
select listagg(ename,',') within group(order by ename) ename_list,
       city,
       --grpno,
       'Team -'||row_number() over(order by city) team_no
       from ds
group by city,grpno;

----Oracle SQL Practical question | SQL to Get Last three consecutive status count

with ds as
            (
            select id,to_date(rep_month,'Mon-yy') rep_month ,status,
                   decode(status,'red',0,1) f,
                   sum(decode(status,'red',0,1)) 
                   over(partition by id order by to_date(rep_month,'Mon-yy') desc) csum
            from reports
            --where id=1
            )
select id,--rep_month,status,csum
       count(*) count
from ds
where csum=0
group by id
having count(*)>=3;

-----end--------------------------------------------

create table values_date
(
dt date,
val varchar(10)
);

insert into values_date values('10-jul-20','A');
insert into values_date values('11-jul-20','A');
insert into values_date values('12-jul-20','B');
insert into values_date values('13-jul-20','A');
insert into values_date values('14-jul-20','A');
insert into values_date values('15-jul-20','A');
insert into values_date values('16-jul-20','B');
insert into values_date values('17-jul-20','B');
insert into values_date values('18-jul-20','C');
insert into values_date values('19-jul-20','C');
insert into values_date values('20-jul-20','A');
insert into values_date values('21-jul-20','A');
commit;

with ds as 
            (
            select dt,val,
                  -- nvl(lag(val) over(order by dt),'A') lval,
                   decode(nvl(lag(val) over(order by dt),'A'),val,0,1) df
            from values_date
            ),
ds2 as (select dt,
       val,
       df,
       sum(df) over(order by dt) csum
from ds)
select min(dt) dt,val,count(*) count from ds2
group by val,csum
order by 1;

---Oracle SQL Practical question | SQL to fill the missing months with previous months salary

create table empsal
(
ename varchar(20),
mnyr varchar(20),
salary number
);

insert into empsal values('Peter','May-19',5000);
insert into empsal values('Peter','Aug-19',10000);
insert into empsal values('Peter','Mar-20',15000);
insert into empsal values('Soloman','Oct-19',20000);
insert into empsal values('Soloman','Feb-20',30000);
commit;

with ds as
    (
        select ename,to_date(mnyr,'Mon-yy') tdate,salary,
               lead(to_date(mnyr,'Mon-yy')) over(partition by ename order by ename) ldate,
               nvl(MONTHS_BETWEEN(lead(to_date(mnyr,'Mon-yy')) over(partition by ename order by ename),
               to_date(mnyr,'Mon-yy')),1) mdate
        from empsal
        order by ename)
select ename,to_char(add_months(tdate,l),'Mon-yy') tdate,salary --mdate 
    from ds,lateral(select level-1 l from dual connect by level<=mdate);
    
-----end---------------------------------