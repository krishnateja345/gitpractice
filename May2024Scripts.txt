---------------24-05-2024---------------------------------
select * from v$version;

select * from v$sql;

select * from all_tables where owner='SYSTEM' and tablespace_name='SYSTEM';

--Problem#1
--Query to get the result which contains 'A' in any of the columns
--You should not use OR Keyword
select * from pract_01;

select * from pract_01 where 'A' in(col1,col2,col3,col4,col5);

select * from pract_01 where col1='A'
union 
select * from pract_01 where col2='A'
union
select * from pract_01 where col3='A'
union 
select * from pract_01 where col4='A'
union
select * from pract_01 where col5='A';

select * from pract_01 where col1||col2||col3||col4||col5 like '%A%';

select * from pract_01 where instr(col1||col2||col3||col4||col5 ,'A')>0;


--Problem#2
--Query to select the employees list who are getting more than average salary
--of the department that are working in
select * from emp;
---Using INLINE VIEW
select empno,ename,a.deptno,sal--,b.avgsal 
from emp a,(select deptno,round(avg(sal)) avgsal from emp
            group by deptno) b
where a.sal>b.avgsal and a.deptno=b.deptno;

--Using CORELATED VIEW
select empno,ename,a.deptno,sal from 
emp a where a.sal>(select avg(sal) from emp b 
                   where b.deptno=a.deptno
                   );
                   
--Using Analytical Function
select EMPNO, ENAME, DEPTNO, SAL from 
(
select empno,ename,deptno,sal,
       trunc(avg(sal) over(partition by deptno)) avgsal
from emp)
where sal>avgsal;

--Using Function
create or replace function get_avg_sal(in_deptno number)
return number
as
v_avg_sal number;
begin
select trunc(avg(sal)) into v_avg_sal from emp
where deptno=in_deptno;
return v_avg_sal;
end;

select get_avg_sal(10) from dual;

select empno,ename,deptno,sal from emp
where sal>get_avg_sal(deptno);
                   
----end-----------------------------------------------------------

-----------------27-05-2024 Script to find the records from tab1 which are not in tab2----
--using NOT IN
select * from tab1 where c1 not in (select * from tab2);

--using NOT EXISTS
select * from tab1 where not exists(select * from tab2 where tab2.c1=tab1.c1);

--using MINUS
select * from tab1
minus
select * from tab2;

--using LEFT OUTER JOIN
select tab1.c1 from tab1 left outer join tab2 on tab2.c1 = tab1.c1
where tab2.c1 is null;

--using OTHER POSSIBILITIES
select * from tab1 where 1>(select count(*) from tab2 where tab1.c1=tab2.c1);

select * from tab1 where (select count(*) from tab2 where tab1.c1=tab2.c1)<1;

---------------Script to generate Cricket Dashboard--------

with t1 as (select  team_name,count(*) matches_played from (
            select team_a team_name from cricket
            union all
            select team_b from cricket)
            group by team_name),
     t2 as (
            select winner,count(*) matches_won from cricket
            group by winner
            )
select TEAM_NAME, 
       MATCHES_PLAYED, 
       nvl(MATCHES_WON,0) MATCHES_WON ,
       MATCHES_PLAYED-nvl(MATCHES_WON,0) MATHCES_LOST
from t1 left outer join t2 on t1.team_name=t2.winner;

select winner,count(*) matches_won from cricket
group by winner;

-----Function to generate Cricket Board
create or replace function matches_played(in_team_name varchar)
return number
as
v_matches_played number;
begin
            select count(*) into v_matches_played from cricket
            where team_a=in_team_name or team_b=in_team_name;
return v_matches_played;
end matches_played;
/

create or replace function matches_won(in_winner varchar)
return number
as
v_matches_won number;
begin
            select count(*) into v_matches_won from cricket
            where winner=in_winner;
return v_matches_won;
end matches_won;
/

select team_name,
       matches_played(team_name) matches_played,
       matches_won(team_name) matches_won,
       matches_played(team_name)-matches_won(team_name) matches_lost
from
(
select team_a team_name from cricket
union
select team_b from cricket);

----------------end  27-05-2024-------------------------------------------------

-----28-05-2024  Oracle sql practice exercise with solution | SQL query to print sequence of numbers

select rownum,e.* from emp e;

select rownum rn from dual
connect by level<=10;

select level l from dual
connect by level<=10;


with t1(id) as
(select 1 id from dual
union all
select id+1 from t1 where id<10
)
select id from t1;

select rownum sno from
(select 1 from dual
group by cube(1,2,3,4))
where rownum<=10;

select rownum sno from xmltable(' 1 to 10 ');

----Oracle sql practice exercise with solution | SQL query to print string in row of characters |PYRAMID

with ds as
(select 'WELCOME' str from dual)
select level l,
       str,
       substr(str,level,1) a,
       substr(str,level*-1,1) b,
       substr(str,1,level) c,
       substr(str,level) d ,
       rpad(' ',level,' ')||substr(str,level) e,
       rpad(' ',length(str)+1-level,' ')||substr(str,1,level) f
from ds
connect by level<=length(str);

------------------end 28-05-2024----------------------

---------29-05-2024  Oracle SQL Practical question with answer extract names from fixed format mail id using SQL function

with t1 as 
        (
        select mail_name m from mail_det
        --where rownum=1
        ),
t2 as (select m,
       instr(m,'.',1,1) fdot,
       instr(m,'.',1,2) sdot,
       instr(m,'@',1,1) tdot
from t1)
select M, 
       --FDOT, SDOT, TDOT, 
       substr(m,1,tdot-1) uname,
       substr(m,1,fdot-1) firstname,
       substr(m,fdot+1,sdot-fdot-1) middlename,
       substr(m,sdot+1,tdot-sdot-1) lastname,
       substr(m,tdot+1) domainname
from t2;

--------- Oracle SQL Practical question with answer extract names from different format mail id using SQL function
with t1 as
(
select mail_name m,
       substr(mail_name,1,instr(mail_name,'@')-1) n,
       substr(mail_name,instr(mail_name,'@')+1) d
from mail_det1
),
t2 as(select m,n,d,
       instr(n,'.',1,1) fdot,
       instr(n,'.',1,2) sdot
from t1)
select M, N,  --FDOT, SDOT,
       substr(n,1,decode(fdot,0,length(n),fdot-1)) first_name,
       decode(sdot,0,null,substr(n,fdot+1,sdot-fdot-1)) middle_name,
       decode(fdot+sdot,0,null,decode(sdot,0,substr(n,fdot+1),substr(n,sdot+1)))
       last_name,
       d domain_name
from t2;

---test cases
select * from mail_det1;

insert into mail_det1 values('tejeshwar@gmail.com');
commit;

insert into mail_det1 values('ravi.krishna@gmail.com');
insert into mail_det1 values('prabhu.deva.123@gmail.com');
commit;

-------------end 29-05-2024-----------------------------

----------30-05-2024  Oracle SQL Practical question with answer calculate the group salary
select empno,ename,mgr,sal from emp;

select sum(sal) grp_sal
from emp
start with ename='JONES'
connect by prior empno=mgr;

select empno,ename,mgr,sal,
(select sum(sal) 
from emp b
start with b.ename=a.ename
connect by prior empno=mgr) grp_sal
from emp a;

----Oracle SQL Practical question with answer Compute Student Result Dashboard
--Year on X-axis and Dept on Y-axis
with t1 as 
        (select dept,year,count(*) n,
        'P= '||count(case when result='P' then result end) ||',F= '||
       count(case when result='F' then result end) P_F_Count
        from students
        group by dept,year
        order by year)       
select dept,
       max(case when year=1 then p_f_count end) I_Year,
       max(case when year=2 then p_f_count end) II_Year,
       max(case when year=3 then p_f_count end) III_Year,
       max(case when year=4 then p_f_count end) IV_Year      
       from t1
group by dept;

--Dept on X-axis and Year on Y-axis
with t1 as 
        (select dept,year,count(*) n,
        'P= '||count(case when result='P' then result end) ||',F= '||
       count(case when result='F' then result end) P_F_Count
        from students
        group by dept,year
        order by year)       
select year,
       max(case when dept='EEE' then p_f_count end) EEE,
       max(case when dept='CSE' then p_f_count end) CSE,
       max(case when dept='CVE' then p_f_count end) CVE,
       max(case when dept='MECH' then p_f_count end) MECH,
       max(case when dept='ECE' then p_f_count end) ECE
       from t1
group by year;


-----using pivot--------------------
--Year on X-axis and Dept on Y-axis
select * from
(select dept,year,
        'P= '||count(case when result='P' then result end) ||',F= '||
       count(case when result='F' then result end) P_F_Count
        from students
        group by dept,year
        order by year)
pivot(max(P_F_Count) for year in(1,2,3,4));

--Dept on X-axis and Year on Y-axis
select * from
(select dept,year,
        'P= '||count(case when result='P' then result end) ||',F= '||
       count(case when result='F' then result end) P_F_Count
        from students
        group by dept,year
        order by year)
pivot(max(P_F_Count) for dept in('EEE','CSE','CVE','MECH','ECE'));
        


-----end 30-05-2024-----------------

---------------31-05-2024 Oracle SQL Practical question with answer Compute all the possible paths | Oracle SELF JOIN Example
--First Method
select --a.city_id,
       a.city_name city1,
       --b.city_id,
       b.city_name city2
from cities a,cities b
where a.city_id<b.city_id;

--Second Method
select distinct
       greatest(a.city_name,b.city_name) city1,
       least(a.city_name,b.city_name) cityb
       --a.city_name,
       --b.city_name
from cities a,cities b
where a.city_name<>b.city_name;

---------------query to get list of persons working under each employee------

--------------query with inline view in the from clause----------------
select empno,ename,mgr from emp;


select mgr,
       listagg(ename,',') within group(order by ename) emps_list,
       count(*) emps_cnt
from emp
group by mgr
order by mgr;


select empno,
       ename,
       a.mgr,
       nvl(b.emps_list,0) emps_list,
       nvl(b.emps_cnt,0) emps_cnt
from emp a left outer join
         (select mgr,
          listagg(ename,',') within group(order by ename) emps_list,
          count(*) emps_cnt
          from emp
          group by mgr
          order by mgr)b
on a.empno=b.mgr
order by empno;

--------------query with inline view in the select clause----------------

select empno,ename from emp;


select listagg(ename,',') within group(order by ename) emps_list
from emp
where mgr=7566;

select empno,ename,(select listagg(ename,',') within group(order by ename) 
                    from emp
                    where mgr=e.empno) emps_list,
                    (select count(*)
                    from emp
                    where mgr=e.empno) emps_cnt
from emp e
order by empno;


--------------self join--------------
select m.empno,m.ename,
       listagg(e.ename,',') within group(order by e.ename) emp_list,
       count(e.ename) emps_cnt
from emp m left outer join emp e on m.empno=e.mgr
group by m.empno,m.ename
order by m.empno;
-----------------------------end  31-05-2024----------------------------------------------


----01-06-2024  Oracle SQL Practical question Write a sql to replace the comma separated value

create table service (service_code varchar(2),service_name varchar(20));

select * from service;

insert into service values('A','Service-A');
insert into service values('B','Service-B');
insert into service values('C','Service-C');
insert into service values('D','Service-D');
commit;

select * from service;

create table prod_service(prod_code varchar(2),prod_desc varchar(30),service_order varchar(50));

select * from prod_service;


insert into prod_service values('P1','Prod_P1','A,C');
insert into prod_service values('P2','Prod_P2','C,B,D');
insert into prod_service values('P3','Prod_P3','D,A,C,B');
insert into prod_service values('P4','Prod_P4','A,B,C,D');
insert into prod_service values('P5','Prod_P5','D,C,B,A,B');
commit;


select * from prod_service;

select prod_code,prod_desc,service_order,--l,
    --regexp_substr(service_order,'(.*?,){'||(l-1)||'}([^,]*)',1,1,'',2) r_service_code,
    listagg(service.service_name,',') within group(order by l) service_names
    from prod_service,service,
    lateral(select level l from dual connect by level<=regexp_count(service_order,',')+1)
    where service.service_code=regexp_substr(service_order,'(.*?,){'||(l-1)||'}([^,]*)',1,1,'',2)
    group by prod_code,prod_desc,service_order
    order by prod_code;


----query to generate all date ranges for the transactionrecords
select * from daily_trans;

with t1 as
        (
        select trunc(min(tran_date),'MM') tdate, 
        last_day(max(tran_date)) mdate,
        last_day(max(tran_date))-trunc(min(tran_date),'MM')+1 n
        from daily_trans
        ),
t2 as
        (select tdate+level-1 tran_date from t1
        connect by level<=n)
select t2.tran_date,t1.tran_desc,nvl(tran_amount,0) tran_amount
from t2  left outer join daily_trans t1 on t1.tran_date=t2.tran_date
order by t2.tran_date;

--test cases
insert into daily_trans values('01-03-2019','Fee Received',7500);

insert into daily_trans values('21-08-2019','Fee Received',5500);

--------------end 01-06-2024-------------------------------------------


----03-06-2024  Oracle SQL Practical question SQL to Find number of saturday and sunday

with t1 as
        (
        select d,
               trunc(min(d),'MM') startdate,
               last_day(d) lastdate,
               last_day(d)-trunc(min(d),'MM')+1 ndays
        from 
        (
        select to_date('13-05-2025','dd-MM-yyyy') d from dual) a
        ),
t2 as(select startdate+level-1 tdate from t1
connect by level<=ndays)
select --tdate,
to_char(tdate,'day') tday,
count(*) day_count
from t2
where trim(to_char(tdate,'day')) in('saturday','sunday')
group by to_char(tdate,'day');

---Oracle SQL Practical question with answer Write a SQL to print Cricket Dashboard
---performance point of view
select * from cricket;

with t1 as 
        (
        select TEAM_A a, TEAM_B b,
               case when team_a=winner then 1 else 0 end t_a,
               case when team_b=winner then 1 else 0 end t_b
        from cricket),
t2 as (select --a,t_a,b,t_b,r,
       decode(r,1,a,b) teams,
       decode(r,1,t_a,t_b) won_count
from t1,(select rownum r from dual connect by level<=2))
select teams,
       count(won_count) matches_played,
       sum(won_count) matches_won,
       count(won_count)-sum(won_count) matches_lost
       from t2
group by teams;
-----end  03-06-2024----------------------------------

--07-06-2024 Oracle SQL Practical question with answer | SQL to find list of DICE rolled combinations

with t as 
(
select level l from dual connect by level<=6
)
select '('||t1.l || ','||t2.l ||','||t3.l||')' result from t t1,t t2,t t3
where t3.l=t1.l+t2.l;

with t as 
(
select level l from dual connect by level<=6
)
select '('||t1.l || ','||t2.l ||','||t3.l||')' result from t t1,t t2,t t3
where (t3.l=t1.l+t2.l or t2.l=t1.l+t3.l or t1.l=t3.l+t2.l);

---Oracle SQL Practical question with answer | Sort the NUMBERS in the comma separated list
with t as
(
select '3,10,5,1,7,55,75,100,42,12,17' d from dual
),
p as (select --d, 
       regexp_substr(d,'[^,]+',1,level) d1
     from t
     connect by level<=regexp_count(d,',')+1)
select listagg(d1,',') within group(order by to_number(d1)) result from p;

with t as
(
select 'WELCOME'  d from dual
),
p as (select d,
       substr(d,level,1) d1
        from t
        connect by level<=length(d))
select listagg(d1,',') within group(order by d1) result from p;

--end 07-06-2024------------------------------------------------------

--09-06-2024  Oracle SQL Practical question with answer | Reverse the String without using reverse function

with ds as
(
select 'WELCOME' d from dual
)
select reverse(d) result from ds;

with ds as
(
select 'WELCOME' d from dual
),
t1 as (select d,
       substr(d,level,1) d1,
       level l
from ds
connect by level<=length(d))
select --d,d1,l,
       listagg(d1) within group(order by l desc) result
from t1;

---Oracle SQL Practical question with answer | Consolidate two rows as single row
select * from emp_a;--count 11

select * from emp_b;-- count 6

delete from emp_b;

select * from emp_b;--count 0

insert into emp_b
with ds as
(
select empno,ename,rownum,
count(*) over() cnt,
round(count(*) over()/2) rcnt,
round(count(*) over()/2)-rownum reqno
from emp_a),
t1 as(select empno,ename,reqno from ds where reqno>=0),
t2 as (select empno,ename,reqno from ds where reqno<0)
select t1.empno,t1.ename,t2.empno,t2.ename from t1 left outer join t2 on t1.reqno=abs(t2.reqno)
order by 1;

select * from emp_b;

---end  09-06-2024--------------------------------------------

--10-06-2024 Oracle SQL Practical question with answer Fill the missing dates with last not null value

with ds as
(
select min(txn_date) midate,
       max(txn_date) mxdate,
       max(txn_date)-min(txn_date)+1 ndates
from txn_data),
t1 as (select midate+level-1 txn_date from ds
connect by level<=ndates)
select 
t1.txn_date,
--t2.txn_date,
--t2.txn_amount,
last_value(t2.txn_amount ignore nulls) over(order by t1.txn_date) req_txn_amount
from t1 left outer join txn_data t2  on t1.txn_date=t2.txn_date
order by t1.txn_date;

--query to compute start and end value of given sequence
with ds as
(
select 
id,
rownum rno,
id-ROWNUM grpno
from ranges)
select min(id) start_range,max(id) end_range from ds
group by grpno
order by grpno;
-----end 10-06-2023------------------------------------------

--11-06-2024 Oracle SQL Practical question with answer Expand the range to Sequence Numbers
create table ranges2
(
    start_range number,
    end_range number
);

insert into ranges2 values(1,3);
insert into ranges2 values(5,5);
insert into ranges2 values(7,9);
insert into ranges2 values(11,12);
insert into ranges2 values(15,16);
insert into ranges2 values(20,20);
commit;


select t2.r from 
(
select start_range,end_range from ranges_1) t1,
(select rownum r from dual
connect by level<=(select max(end_range) from ranges_1) 
) t2
where t2.r>=t1.start_range and t2.r<=t1.end_range ;

---Second Method


select --start_range,end_range,r-1,
    start_range+r-1 result
    from ranges2,
    lateral(select rownum r from dual connect by level<=end_range-start_range+1);


---Oracle SQL Practical question with answer Grouping The Range Data

create table cars 
(
    name varchar(20),
    start_year number,
    end_year number
);


insert into cars values('Swift',2007,2009);
insert into cars values('Swift',2009,2011);
insert into cars values('Swift',2011,2013);
insert into cars values('Maruthi',2009,2011);
insert into cars values('Maruthi',2013,2015);
commit;


select name,min(req_year) start_year, max(req_year) end_year
    from
    (
select distinct name,--start_year,end_year,r-1,
    start_year+r-1 req_year
    from cars,
     lateral(select rownum r from dual connect by level<=end_year-start_year+1)
order by name,start_year+r-1)
group by name,req_year-rownum;

--end  11-06-2024--------------------------------

----12-06-2024 Oracle SQL Practical question with answer / SQL to check whether given sudoku is resolved


select * from sudoku;

update sudoku set c3=9 where row_no='R3';

commit;

select col_name,col_val col_sum from
        (
        select sum(c1) c1,sum(c2) c2,sum(c3) c3,sum(c4) c4,sum(c5) c5,
        sum(c6) c6,sum(c7) c7,sum(c8) c8,sum(c9) c9 from sudoku
        )
unpivot(col_val for col_name in(c1,c2,c3,c4,c5,c6,c7,c8,c9));
       
select row_no,c1+c2+c3+c4+c5+c6+c7+c8+c9 row_sum from sudoku;

select grp||col_name grp_no,col_val grp_sum from
(
select  'G'||ceil(rownum/3) grp,sum(c1+c2+c3) g1,sum(c4+c5+c6) g2,sum(c7+c8+c9) g3 
from sudoku
group by 'G'||ceil(rownum/3)
order by 1
) unpivot(col_val for col_name in(G1,G2,G3));

--grouping of all the above three select statements rows,cols,grps
select case when sum(distinct col_sum)=45 then 'SUDOKU IS VALID'
       else 'SUDOKU IS INVALID' end Result
from
(
select col_name,col_val col_sum from
        (
        select sum(c1) c1,sum(c2) c2,sum(c3) c3,sum(c4) c4,sum(c5) c5,
        sum(c6) c6,sum(c7) c7,sum(c8) c8,sum(c9) c9 from sudoku
        )
unpivot(col_val for col_name in(c1,c2,c3,c4,c5,c6,c7,c8,c9))
union all
select row_no,c1+c2+c3+c4+c5+c6+c7+c8+c9 row_sum from sudoku
union all
select grp||col_name grp_no,col_val grp_sum from
(
select  'G'||ceil(rownum/3) grp,sum(c1+c2+c3) g1,sum(c4+c5+c6) g2,sum(c7+c8+c9) g3 
from sudoku
group by 'G'||ceil(rownum/3)
order by 1
) unpivot(col_val for col_name in(G1,G2,G3))
);

---Finding where exactly the sudoku puzzle is incorrect
select col_sum val,
       listagg(col_name,',') within group(order by col_name) col_row_grp_names,
       case when sum(distinct col_sum)=45 then 'SUDOKU IS VALID'
       else 'SUDOKU IS INVALID' end Result
from
(
select col_name,col_val col_sum from
        (
        select sum(c1) c1,sum(c2) c2,sum(c3) c3,sum(c4) c4,sum(c5) c5,
        sum(c6) c6,sum(c7) c7,sum(c8) c8,sum(c9) c9 from sudoku
        )
unpivot(col_val for col_name in(c1,c2,c3,c4,c5,c6,c7,c8,c9))
union all
select row_no,c1+c2+c3+c4+c5+c6+c7+c8+c9 row_sum from sudoku
union all
select grp||col_name grp_no,col_val grp_sum from
(
select  'G'||ceil(rownum/3) grp,sum(c1+c2+c3) g1,sum(c4+c5+c6) g2,sum(c7+c8+c9) g3 
from sudoku
group by 'G'||ceil(rownum/3)
order by 1
) unpivot(col_val for col_name in(G1,G2,G3))
)
group by col_sum;

update sudoku set c3=5 where row_no='R3';

commit;

---Oracle SQL Practical question with answer | SQL to convert list of numbers into table format

--x-axis
select c1,c2,c3,c4,c5 from 
(
select level l,
ceil(rownum/5) x,
row_number() over(partition by ceil(rownum/5) order by level) y
from dual
connect by level<=25)
pivot(sum(l) for y in(1 c1,2 c2,3 c3,4 c4,5 c5))
order by 1;

--Y-axis
select c1,c2,c3,c4,c5 from 
(
select level l,
ceil(rownum/5) x,
row_number() over(partition by ceil(rownum/5) order by level) y
from dual
connect by level<=25)
pivot(sum(l) for x in(1 c1,2 c2,3 c3,4 c4,5 c5))
order by 1;

--Using Mod and Ceil Method

with ds as
(
select level d from dual
connect by level<=25
)select --d,
--ceil(d/5),
max(case when mod(d,5)=1 then d end) c1,
max(case when mod(d,5)=2 then d end) c2,
max(case when mod(d,5)=3 then d end) c3,
max(case when mod(d,5)=4 then d end) c4,
max(case when mod(d,5)=0 then d end) c5
from ds
group by ceil(d/5);

--end  12-06-2023---------------------------------------

--13-06-2024 Oracle SQL Practical question | SQL to fetch Emp hierarchical data in Flat format

select EMPNO1, ENAME1, L1, 
       EMPNO2, ENAME2, L2, 
       EMPNO3, ENAME3, L3, 
       EMPNO4, ENAME4, L4, 
       EMPNO empno5, ENAME ename5,
       case when e5.empno is not null then 5 end l5
       from 
(
select EMPNO1, ENAME1, L1, 
       EMPNO2, ENAME2, L2, 
       EMPNO3, ENAME3, L3, 
       EMPNO EMPNO4, ENAME ENAME4,
       case when e4.empno is not null then 4 end l4
       from 
(
select EMPNO1, ENAME1, L1, 
       EMPNO2, ENAME2, L2, 
       EMPNO EMPNO3, ENAME ENAME3,3 L3 from 
(
select e1.EMPNO EMPNO1, e1.ENAME ENAME1, e1.L l1, 
       e2.EMPNO EMPNO2, e2.ENAME ENAME2,2 l2
from (
select empno,ename,1 l from emp e
where mgr is null) e1 left outer join emp e2 on e2.mgr=e1.empno)e2
left outer join emp e3 on e3.mgr=e2.empno2)e3
left outer join emp e4 on e4.mgr=e3.empno3)e4
left outer join emp e5 on e5.mgr=e4.empno4
order by 1,4;

--Second Method
select --empno_lst,ename_lst,
       regexp_substr(empno_lst,'\w+',1,1) empno1,regexp_substr(ename_lst,'\w+',1,1) ename1,1 l1,
       regexp_substr(empno_lst,'\w+',1,2) empno2,regexp_substr(ename_lst,'\w+',1,2) ename2,2 l2,
       regexp_substr(empno_lst,'\w+',1,3) empno3,regexp_substr(ename_lst,'\w+',1,3) ename3,3 l3,
       regexp_substr(empno_lst,'\w+',1,4) empno4,regexp_substr(ename_lst,'\w+',1,4) ename4,
       case when regexp_substr(empno_lst,'\w+',1,4) is not null then 4 end l4,
       regexp_substr(empno_lst,'\w+',1,5) empno5,regexp_substr(ename_lst,'\w+',1,5) ename5,
       case when regexp_substr(empno_lst,'\w+',1,5) is not null then 5 end l5
from
(
select empno,ename,
        trim(',' from sys_connect_by_path(empno,',')) empno_lst,
        trim(',' from sys_connect_by_path(ename,',')) ename_lst,
        CONNECT_BY_ISLEAF is_leaf
from emp
connect by prior empno=mgr
start with mgr is null)
where is_leaf=1
order by 1,4;

--Oracle SQL Practical question | SQL to group the employees into multiple team
--2 members each group
select city,listagg(ename,',') within group(order by ename) empnames,
       'Team-'||row_number() over(order by city) teamname
from 
(
select city,ename,ceil(row_number() over(partition by city order by rownum)/2) grp from emp_city
)
group by city,grp;

--3 members each group
select city,listagg(ename,',') within group(order by ename) empnames,
       'Team-'||row_number() over(order by city) teamname
from 
(
select city,ename,ceil(row_number() over(partition by city order by rownum)/3) grp from emp_city
)
group by city,grp;

--4 members each group
select city,listagg(ename,',') within group(order by ename) empnames,
       'Team-'||row_number() over(order by city) teamname
from 
(
select city,ename,ceil(row_number() over(partition by city order by rownum)/4) grp from emp_city
)
group by city,grp;

---end 13-06-2024--------------------------------------

--14-06-2024  Oracle SQL Practical question | SQL to Get Last three consecutive status count

with ds as
(
select id,rep_month,status,
       decode(status,'red',0,1) flag
from reports
--where id=3
),
t1 as (select id,rep_month,status,flag,
       sum(flag) over(partition by id order by to_date(rep_month,'Mon-yy') desc) sflag
from ds)
select id,count(*) id_count from t1 where sflag=0
group by id
having count(*)>=3;

--Oracle SQL Practical question | SQL to summarize data one row for continuous play of album

with ds as
(
select dt,val,
nvl(lag(val) over(order by dt),val) lval
from values_date
),
t1 as (select dt,
val,
--lval,
--decode(val,lval,0,1) dval,
sum(decode(val,lval,0,1)) over(order by dt) sval
from ds)
select to_char(min(dt),'dd-MON-yy')tdate,val,count(*) val_count from t1
group by val,sval
order by 1;

--end 14-06-2024--------------------------------

--19-06-2024 Oracle SQL Practical question | SQL to fill the missing months with previous months salary

/*
create table empsal
(
ename varchar(50),
mnyr varchar(50),
salary number
)

insert into empsal values('peter','May-19',5000);
insert into empsal values('peter','Aug-19',10000);
insert into empsal values('peter','Mar-20',15000);
insert into empsal values('soloman','Oct-19',20000);
insert into empsal values('soloman','Feb-20',30000);
commit;

select * from empsal;


*/


with ds as
(
select ename,to_date(mnyr,'MM-yy') dt,salary from empsal
),
t1 as 
(select ename,dt,lead(dt,1) over(partition by ename order by dt) nxtdt,salary from ds
order by ename),
t2 as (select ename,
    dt,
    nxtdt,
    salary,
    months_between(nxtdt,dt),
    r-1,
    add_months(dt,r-1) rdt
    from t1,
lateral(select rownum r from dual connect by level<=months_between(nxtdt,dt)))
select ename,to_char(rdt,'Mon-yy') rdt,salary from t2;

--Oracle SQL Practical question | SQL to count number of occurrences of a vowels in a string

with ds
as(
select 'WELCOME' str from dual
)
select str,
       regexp_count(str,'A') A,
       regexp_count(str,'E') E,
       regexp_count(str,'I') I,
       regexp_count(str,'O') O,
       regexp_count(str,'U') U
       
from ds
-- connect by level<=length(str)
;

--second method

with ds
    as
    (select distinct ename from empsal --where ename='peter'
    ),
t1 as (select ename,r,
    upper(substr(ename,r,1)) sename
    from ds,
lateral(select rownum r from dual connect by level<=length(ename)))
select * from 
    (select ename,sename,count(*) cnt from t1 where sename in('A','E','I','O','U')
    group by ename,sename) pivot(max(cnt) for sename in('A','E','I','O','U') );

--end 19-06-2024----------------------------------