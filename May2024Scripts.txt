---------------24-05-2024---------------------------------
select * from v$version;

select * from v$sql;

select * from all_tables where owner='SYSTEM' and tablespace_name='SYSTEM';

--Problem#1
--Query to get the result which contains 'A' in any of the columns
--You should not use OR Keyword
select * from pract_01;

select * from pract_01 where 'A' in(col1,col2,col3,col4,col5);

select * from pract_01 where col1='A'
union 
select * from pract_01 where col2='A'
union
select * from pract_01 where col3='A'
union 
select * from pract_01 where col4='A'
union
select * from pract_01 where col5='A';

select * from pract_01 where col1||col2||col3||col4||col5 like '%A%';

select * from pract_01 where instr(col1||col2||col3||col4||col5 ,'A')>0;


--Problem#2
--Query to select the employees list who are getting more than average salary
--of the department that are working in
select * from emp;
---Using INLINE VIEW
select empno,ename,a.deptno,sal--,b.avgsal 
from emp a,(select deptno,round(avg(sal)) avgsal from emp
            group by deptno) b
where a.sal>b.avgsal and a.deptno=b.deptno;

--Using CORELATED VIEW
select empno,ename,a.deptno,sal from 
emp a where a.sal>(select avg(sal) from emp b 
                   where b.deptno=a.deptno
                   );
                   
--Using Analytical Function
select EMPNO, ENAME, DEPTNO, SAL from 
(
select empno,ename,deptno,sal,
       trunc(avg(sal) over(partition by deptno)) avgsal
from emp)
where sal>avgsal;

--Using Function
create or replace function get_avg_sal(in_deptno number)
return number
as
v_avg_sal number;
begin
select trunc(avg(sal)) into v_avg_sal from emp
where deptno=in_deptno;
return v_avg_sal;
end;

select get_avg_sal(10) from dual;

select empno,ename,deptno,sal from emp
where sal>get_avg_sal(deptno);
                   
----end-----------------------------------------------------------

-----------------27-05-2024 Script to find the records from tab1 which are not in tab2----
--using NOT IN
select * from tab1 where c1 not in (select * from tab2);

--using NOT EXISTS
select * from tab1 where not exists(select * from tab2 where tab2.c1=tab1.c1);

--using MINUS
select * from tab1
minus
select * from tab2;

--using LEFT OUTER JOIN
select tab1.c1 from tab1 left outer join tab2 on tab2.c1 = tab1.c1
where tab2.c1 is null;

--using OTHER POSSIBILITIES
select * from tab1 where 1>(select count(*) from tab2 where tab1.c1=tab2.c1);

select * from tab1 where (select count(*) from tab2 where tab1.c1=tab2.c1)<1;

---------------Script to generate Cricket Dashboard--------

with t1 as (select  team_name,count(*) matches_played from (
            select team_a team_name from cricket
            union all
            select team_b from cricket)
            group by team_name),
     t2 as (
            select winner,count(*) matches_won from cricket
            group by winner
            )
select TEAM_NAME, 
       MATCHES_PLAYED, 
       nvl(MATCHES_WON,0) MATCHES_WON ,
       MATCHES_PLAYED-nvl(MATCHES_WON,0) MATHCES_LOST
from t1 left outer join t2 on t1.team_name=t2.winner;

select winner,count(*) matches_won from cricket
group by winner;

-----Function to generate Cricket Board
create or replace function matches_played(in_team_name varchar)
return number
as
v_matches_played number;
begin
            select count(*) into v_matches_played from cricket
            where team_a=in_team_name or team_b=in_team_name;
return v_matches_played;
end matches_played;
/

create or replace function matches_won(in_winner varchar)
return number
as
v_matches_won number;
begin
            select count(*) into v_matches_won from cricket
            where winner=in_winner;
return v_matches_won;
end matches_won;
/

select team_name,
       matches_played(team_name) matches_played,
       matches_won(team_name) matches_won,
       matches_played(team_name)-matches_won(team_name) matches_lost
from
(
select team_a team_name from cricket
union
select team_b from cricket);

----------------end  27-05-2024-------------------------------------------------

-----28-05-2024  Oracle sql practice exercise with solution | SQL query to print sequence of numbers

select rownum,e.* from emp e;

select rownum rn from dual
connect by level<=10;

select level l from dual
connect by level<=10;


with t1(id) as
(select 1 id from dual
union all
select id+1 from t1 where id<10
)
select id from t1;

select rownum sno from
(select 1 from dual
group by cube(1,2,3,4))
where rownum<=10;

select rownum sno from xmltable(' 1 to 10 ');

----Oracle sql practice exercise with solution | SQL query to print string in row of characters |PYRAMID

with ds as
(select 'WELCOME' str from dual)
select level l,
       str,
       substr(str,level,1) a,
       substr(str,level*-1,1) b,
       substr(str,1,level) c,
       substr(str,level) d ,
       rpad(' ',level,' ')||substr(str,level) e,
       rpad(' ',length(str)+1-level,' ')||substr(str,1,level) f
from ds
connect by level<=length(str);

------------------end 28-05-2024----------------------

---------29-05-2024  Oracle SQL Practical question with answer extract names from fixed format mail id using SQL function

with t1 as 
        (
        select mail_name m from mail_det
        --where rownum=1
        ),
t2 as (select m,
       instr(m,'.',1,1) fdot,
       instr(m,'.',1,2) sdot,
       instr(m,'@',1,1) tdot
from t1)
select M, 
       --FDOT, SDOT, TDOT, 
       substr(m,1,tdot-1) uname,
       substr(m,1,fdot-1) firstname,
       substr(m,fdot+1,sdot-fdot-1) middlename,
       substr(m,sdot+1,tdot-sdot-1) lastname,
       substr(m,tdot+1) domainname
from t2;

--------- Oracle SQL Practical question with answer extract names from different format mail id using SQL function
with t1 as
(
select mail_name m,
       substr(mail_name,1,instr(mail_name,'@')-1) n,
       substr(mail_name,instr(mail_name,'@')+1) d
from mail_det1
),
t2 as(select m,n,d,
       instr(n,'.',1,1) fdot,
       instr(n,'.',1,2) sdot
from t1)
select M, N,  --FDOT, SDOT,
       substr(n,1,decode(fdot,0,length(n),fdot-1)) first_name,
       decode(sdot,0,null,substr(n,fdot+1,sdot-fdot-1)) middle_name,
       decode(fdot+sdot,0,null,decode(sdot,0,substr(n,fdot+1),substr(n,sdot+1)))
       last_name,
       d domain_name
from t2;

---test cases
select * from mail_det1;

insert into mail_det1 values('tejeshwar@gmail.com');
commit;

insert into mail_det1 values('ravi.krishna@gmail.com');
insert into mail_det1 values('prabhu.deva.123@gmail.com');
commit;

-------------end 29-05-2024-----------------------------

----------30-05-2024  Oracle SQL Practical question with answer calculate the group salary
select empno,ename,mgr,sal from emp;

select sum(sal) grp_sal
from emp
start with ename='JONES'
connect by prior empno=mgr;

select empno,ename,mgr,sal,
(select sum(sal) 
from emp b
start with b.ename=a.ename
connect by prior empno=mgr) grp_sal
from emp a;

----Oracle SQL Practical question with answer Compute Student Result Dashboard
--Year on X-axis and Dept on Y-axis
with t1 as 
        (select dept,year,count(*) n,
        'P= '||count(case when result='P' then result end) ||',F= '||
       count(case when result='F' then result end) P_F_Count
        from students
        group by dept,year
        order by year)       
select dept,
       max(case when year=1 then p_f_count end) I_Year,
       max(case when year=2 then p_f_count end) II_Year,
       max(case when year=3 then p_f_count end) III_Year,
       max(case when year=4 then p_f_count end) IV_Year      
       from t1
group by dept;

--Dept on X-axis and Year on Y-axis
with t1 as 
        (select dept,year,count(*) n,
        'P= '||count(case when result='P' then result end) ||',F= '||
       count(case when result='F' then result end) P_F_Count
        from students
        group by dept,year
        order by year)       
select year,
       max(case when dept='EEE' then p_f_count end) EEE,
       max(case when dept='CSE' then p_f_count end) CSE,
       max(case when dept='CVE' then p_f_count end) CVE,
       max(case when dept='MECH' then p_f_count end) MECH,
       max(case when dept='ECE' then p_f_count end) ECE
       from t1
group by year;


-----using pivot--------------------
--Year on X-axis and Dept on Y-axis
select * from
(select dept,year,
        'P= '||count(case when result='P' then result end) ||',F= '||
       count(case when result='F' then result end) P_F_Count
        from students
        group by dept,year
        order by year)
pivot(max(P_F_Count) for year in(1,2,3,4));

--Dept on X-axis and Year on Y-axis
select * from
(select dept,year,
        'P= '||count(case when result='P' then result end) ||',F= '||
       count(case when result='F' then result end) P_F_Count
        from students
        group by dept,year
        order by year)
pivot(max(P_F_Count) for dept in('EEE','CSE','CVE','MECH','ECE'));
        


-----end 30-05-2024-----------------

---------------31-05-2024 Oracle SQL Practical question with answer Compute all the possible paths | Oracle SELF JOIN Example
--First Method
select --a.city_id,
       a.city_name city1,
       --b.city_id,
       b.city_name city2
from cities a,cities b
where a.city_id<b.city_id;

--Second Method
select distinct
       greatest(a.city_name,b.city_name) city1,
       least(a.city_name,b.city_name) cityb
       --a.city_name,
       --b.city_name
from cities a,cities b
where a.city_name<>b.city_name;

---------------query to get list of persons working under each employee------

--------------query with inline view in the from clause----------------
select empno,ename,mgr from emp;


select mgr,
       listagg(ename,',') within group(order by ename) emps_list,
       count(*) emps_cnt
from emp
group by mgr
order by mgr;


select empno,
       ename,
       a.mgr,
       nvl(b.emps_list,0) emps_list,
       nvl(b.emps_cnt,0) emps_cnt
from emp a left outer join
         (select mgr,
          listagg(ename,',') within group(order by ename) emps_list,
          count(*) emps_cnt
          from emp
          group by mgr
          order by mgr)b
on a.empno=b.mgr
order by empno;

--------------query with inline view in the select clause----------------

select empno,ename from emp;


select listagg(ename,',') within group(order by ename) emps_list
from emp
where mgr=7566;

select empno,ename,(select listagg(ename,',') within group(order by ename) 
                    from emp
                    where mgr=e.empno) emps_list,
                    (select count(*)
                    from emp
                    where mgr=e.empno) emps_cnt
from emp e
order by empno;


--------------self join--------------
select m.empno,m.ename,
       listagg(e.ename,',') within group(order by e.ename) emp_list,
       count(e.ename) emps_cnt
from emp m left outer join emp e on m.empno=e.mgr
group by m.empno,m.ename
order by m.empno;
-----------------------------end  31-05-2024----------------------------------------------


----01-06-2024  Oracle SQL Practical question Write a sql to replace the comma separated value

create table service (service_code varchar(2),service_name varchar(20));

select * from service;

insert into service values('A','Service-A');
insert into service values('B','Service-B');
insert into service values('C','Service-C');
insert into service values('D','Service-D');
commit;

select * from service;

create table prod_service(prod_code varchar(2),prod_desc varchar(30),service_order varchar(50));

select * from prod_service;


insert into prod_service values('P1','Prod_P1','A,C');
insert into prod_service values('P2','Prod_P2','C,B,D');
insert into prod_service values('P3','Prod_P3','D,A,C,B');
insert into prod_service values('P4','Prod_P4','A,B,C,D');
insert into prod_service values('P5','Prod_P5','D,C,B,A,B');
commit;


select * from prod_service;

select prod_code,prod_desc,service_order,--l,
    --regexp_substr(service_order,'(.*?,){'||(l-1)||'}([^,]*)',1,1,'',2) r_service_code,
    listagg(service.service_name,',') within group(order by l) service_names
    from prod_service,service,
    lateral(select level l from dual connect by level<=regexp_count(service_order,',')+1)
    where service.service_code=regexp_substr(service_order,'(.*?,){'||(l-1)||'}([^,]*)',1,1,'',2)
    group by prod_code,prod_desc,service_order
    order by prod_code;


----query to generate all date ranges for the transactionrecords
select * from daily_trans;

with t1 as
        (
        select trunc(min(tran_date),'MM') tdate, 
        last_day(max(tran_date)) mdate,
        last_day(max(tran_date))-trunc(min(tran_date),'MM')+1 n
        from daily_trans
        ),
t2 as
        (select tdate+level-1 tran_date from t1
        connect by level<=n)
select t2.tran_date,t1.tran_desc,nvl(tran_amount,0) tran_amount
from t2  left outer join daily_trans t1 on t1.tran_date=t2.tran_date
order by t2.tran_date;

--test cases
insert into daily_trans values('01-03-2019','Fee Received',7500);

insert into daily_trans values('21-08-2019','Fee Received',5500);

--------------end 01-06-2024-------------------------------------------


----03-06-2024  Oracle SQL Practical question SQL to Find number of saturday and sunday

with t1 as
        (
        select d,
               trunc(min(d),'MM') startdate,
               last_day(d) lastdate,
               last_day(d)-trunc(min(d),'MM')+1 ndays
        from 
        (
        select to_date('13-05-2025','dd-MM-yyyy') d from dual) a
        ),
t2 as(select startdate+level-1 tdate from t1
connect by level<=ndays)
select --tdate,
to_char(tdate,'day') tday,
count(*) day_count
from t2
where trim(to_char(tdate,'day')) in('saturday','sunday')
group by to_char(tdate,'day');

---Oracle SQL Practical question with answer Write a SQL to print Cricket Dashboard
---performance point of view
select * from cricket;

with t1 as 
        (
        select TEAM_A a, TEAM_B b,
               case when team_a=winner then 1 else 0 end t_a,
               case when team_b=winner then 1 else 0 end t_b
        from cricket),
t2 as (select --a,t_a,b,t_b,r,
       decode(r,1,a,b) teams,
       decode(r,1,t_a,t_b) won_count
from t1,(select rownum r from dual connect by level<=2))
select teams,
       count(won_count) matches_played,
       sum(won_count) matches_won,
       count(won_count)-sum(won_count) matches_lost
       from t2
group by teams;
-----end  03-06-2024----------------------------------

--07-06-2024 Oracle SQL Practical question with answer | SQL to find list of DICE rolled combinations

with t as 
(
select level l from dual connect by level<=6
)
select '('||t1.l || ','||t2.l ||','||t3.l||')' result from t t1,t t2,t t3
where t3.l=t1.l+t2.l;

with t as 
(
select level l from dual connect by level<=6
)
select '('||t1.l || ','||t2.l ||','||t3.l||')' result from t t1,t t2,t t3
where (t3.l=t1.l+t2.l or t2.l=t1.l+t3.l or t1.l=t3.l+t2.l);

---Oracle SQL Practical question with answer | Sort the NUMBERS in the comma separated list
with t as
(
select '3,10,5,1,7,55,75,100,42,12,17' d from dual
),
p as (select --d, 
       regexp_substr(d,'[^,]+',1,level) d1
     from t
     connect by level<=regexp_count(d,',')+1)
select listagg(d1,',') within group(order by to_number(d1)) result from p;

with t as
(
select 'WELCOME'  d from dual
),
p as (select d,
       substr(d,level,1) d1
        from t
        connect by level<=length(d))
select listagg(d1,',') within group(order by d1) result from p;

--end 07-06-2024------------------------------------------------------








