---------------24-05-2024---------------------------------
select * from v$version;

select * from v$sql;

select * from all_tables where owner='SYSTEM' and tablespace_name='SYSTEM';

--Problem#1
--Query to get the result which contains 'A' in any of the columns
--You should not use OR Keyword
select * from pract_01;

select * from pract_01 where 'A' in(col1,col2,col3,col4,col5);

select * from pract_01 where col1='A'
union 
select * from pract_01 where col2='A'
union
select * from pract_01 where col3='A'
union 
select * from pract_01 where col4='A'
union
select * from pract_01 where col5='A';

select * from pract_01 where col1||col2||col3||col4||col5 like '%A%';

select * from pract_01 where instr(col1||col2||col3||col4||col5 ,'A')>0;


--Problem#2
--Query to select the employees list who are getting more than average salary
--of the department that are working in
select * from emp;
---Using INLINE VIEW
select empno,ename,a.deptno,sal--,b.avgsal 
from emp a,(select deptno,round(avg(sal)) avgsal from emp
            group by deptno) b
where a.sal>b.avgsal and a.deptno=b.deptno;

--Using CORELATED VIEW
select empno,ename,a.deptno,sal from 
emp a where a.sal>(select avg(sal) from emp b 
                   where b.deptno=a.deptno
                   );
                   
--Using Analytical Function
select EMPNO, ENAME, DEPTNO, SAL from 
(
select empno,ename,deptno,sal,
       trunc(avg(sal) over(partition by deptno)) avgsal
from emp)
where sal>avgsal;

--Using Function
create or replace function get_avg_sal(in_deptno number)
return number
as
v_avg_sal number;
begin
select trunc(avg(sal)) into v_avg_sal from emp
where deptno=in_deptno;
return v_avg_sal;
end;

select get_avg_sal(10) from dual;

select empno,ename,deptno,sal from emp
where sal>get_avg_sal(deptno);
                   
----end-----------------------------------------------------------

-----------------27-05-2024 Script to find the records from tab1 which are not in tab2----
--using NOT IN
select * from tab1 where c1 not in (select * from tab2);

--using NOT EXISTS
select * from tab1 where not exists(select * from tab2 where tab2.c1=tab1.c1);

--using MINUS
select * from tab1
minus
select * from tab2;

--using LEFT OUTER JOIN
select tab1.c1 from tab1 left outer join tab2 on tab2.c1 = tab1.c1
where tab2.c1 is null;

--using OTHER POSSIBILITIES
select * from tab1 where 1>(select count(*) from tab2 where tab1.c1=tab2.c1);

select * from tab1 where (select count(*) from tab2 where tab1.c1=tab2.c1)<1;

---------------Script to generate Cricket Dashboard--------

with t1 as (select  team_name,count(*) matches_played from (
            select team_a team_name from cricket
            union all
            select team_b from cricket)
            group by team_name),
     t2 as (
            select winner,count(*) matches_won from cricket
            group by winner
            )
select TEAM_NAME, 
       MATCHES_PLAYED, 
       nvl(MATCHES_WON,0) MATCHES_WON ,
       MATCHES_PLAYED-nvl(MATCHES_WON,0) MATHCES_LOST
from t1 left outer join t2 on t1.team_name=t2.winner;

select winner,count(*) matches_won from cricket
group by winner;

-----Function to generate Cricket Board
create or replace function matches_played(in_team_name varchar)
return number
as
v_matches_played number;
begin
            select count(*) into v_matches_played from cricket
            where team_a=in_team_name or team_b=in_team_name;
return v_matches_played;
end matches_played;
/

create or replace function matches_won(in_winner varchar)
return number
as
v_matches_won number;
begin
            select count(*) into v_matches_won from cricket
            where winner=in_winner;
return v_matches_won;
end matches_won;
/

select team_name,
       matches_played(team_name) matches_played,
       matches_won(team_name) matches_won,
       matches_played(team_name)-matches_won(team_name) matches_lost
from
(
select team_a team_name from cricket
union
select team_b from cricket);

----------------end  27-05-2024-------------------------------------------------

-----28-05-2024  Oracle sql practice exercise with solution | SQL query to print sequence of numbers

select rownum,e.* from emp e;

select rownum rn from dual
connect by level<=10;

select level l from dual
connect by level<=10;


with t1(id) as
(select 1 id from dual
union all
select id+1 from t1 where id<10
)
select id from t1;

select rownum sno from
(select 1 from dual
group by cube(1,2,3,4))
where rownum<=10;

select rownum sno from xmltable(' 1 to 10 ');

----Oracle sql practice exercise with solution | SQL query to print string in row of characters |PYRAMID

with ds as
(select 'WELCOME' str from dual)
select level l,
       str,
       substr(str,level,1) a,
       substr(str,level*-1,1) b,
       substr(str,1,level) c,
       substr(str,level) d ,
       rpad(' ',level,' ')||substr(str,level) e,
       rpad(' ',length(str)+1-level,' ')||substr(str,1,level) f
from ds
connect by level<=length(str);

------------------end 28-05-2024----------------------

---------29-05-2024  Oracle SQL Practical question with answer extract names from fixed format mail id using SQL function

with t1 as 
        (
        select mail_name m from mail_det
        --where rownum=1
        ),
t2 as (select m,
       instr(m,'.',1,1) fdot,
       instr(m,'.',1,2) sdot,
       instr(m,'@',1,1) tdot
from t1)
select M, 
       --FDOT, SDOT, TDOT, 
       substr(m,1,tdot-1) uname,
       substr(m,1,fdot-1) firstname,
       substr(m,fdot+1,sdot-fdot-1) middlename,
       substr(m,sdot+1,tdot-sdot-1) lastname,
       substr(m,tdot+1) domainname
from t2;

--------- Oracle SQL Practical question with answer extract names from different format mail id using SQL function
with t1 as
(
select mail_name m,
       substr(mail_name,1,instr(mail_name,'@')-1) n,
       substr(mail_name,instr(mail_name,'@')+1) d
from mail_det1
),
t2 as(select m,n,d,
       instr(n,'.',1,1) fdot,
       instr(n,'.',1,2) sdot
from t1)
select M, N,  --FDOT, SDOT,
       substr(n,1,decode(fdot,0,length(n),fdot-1)) first_name,
       decode(sdot,0,null,substr(n,fdot+1,sdot-fdot-1)) middle_name,
       decode(fdot+sdot,0,null,decode(sdot,0,substr(n,fdot+1),substr(n,sdot+1)))
       last_name,
       d domain_name
from t2;

---test cases
select * from mail_det1;

insert into mail_det1 values('tejeshwar@gmail.com');
commit;

insert into mail_det1 values('ravi.krishna@gmail.com');
insert into mail_det1 values('prabhu.deva.123@gmail.com');
commit;

-------------end 29-05-2024-----------------------------

----------30-05-2024  Oracle SQL Practical question with answer calculate the group salary
select empno,ename,mgr,sal from emp;

select sum(sal) grp_sal
from emp
start with ename='JONES'
connect by prior empno=mgr;

select empno,ename,mgr,sal,
(select sum(sal) 
from emp b
start with b.ename=a.ename
connect by prior empno=mgr) grp_sal
from emp a;

----Oracle SQL Practical question with answer Compute Student Result Dashboard
--Year on X-axis and Dept on Y-axis
with t1 as 
        (select dept,year,count(*) n,
        'P= '||count(case when result='P' then result end) ||',F= '||
       count(case when result='F' then result end) P_F_Count
        from students
        group by dept,year
        order by year)       
select dept,
       max(case when year=1 then p_f_count end) I_Year,
       max(case when year=2 then p_f_count end) II_Year,
       max(case when year=3 then p_f_count end) III_Year,
       max(case when year=4 then p_f_count end) IV_Year      
       from t1
group by dept;

--Dept on X-axis and Year on Y-axis
with t1 as 
        (select dept,year,count(*) n,
        'P= '||count(case when result='P' then result end) ||',F= '||
       count(case when result='F' then result end) P_F_Count
        from students
        group by dept,year
        order by year)       
select year,
       max(case when dept='EEE' then p_f_count end) EEE,
       max(case when dept='CSE' then p_f_count end) CSE,
       max(case when dept='CVE' then p_f_count end) CVE,
       max(case when dept='MECH' then p_f_count end) MECH,
       max(case when dept='ECE' then p_f_count end) ECE
       from t1
group by year;


-----using pivot--------------------
--Year on X-axis and Dept on Y-axis
select * from
(select dept,year,
        'P= '||count(case when result='P' then result end) ||',F= '||
       count(case when result='F' then result end) P_F_Count
        from students
        group by dept,year
        order by year)
pivot(max(P_F_Count) for year in(1,2,3,4));

--Dept on X-axis and Year on Y-axis
select * from
(select dept,year,
        'P= '||count(case when result='P' then result end) ||',F= '||
       count(case when result='F' then result end) P_F_Count
        from students
        group by dept,year
        order by year)
pivot(max(P_F_Count) for dept in('EEE','CSE','CVE','MECH','ECE'));
        


-----end 30-05-2024-----------------

---------------31-05-2024 Oracle SQL Practical question with answer Compute all the possible paths | Oracle SELF JOIN Example
--First Method
select --a.city_id,
       a.city_name city1,
       --b.city_id,
       b.city_name city2
from cities a,cities b
where a.city_id<b.city_id;

--Second Method
select distinct
       greatest(a.city_name,b.city_name) city1,
       least(a.city_name,b.city_name) cityb
       --a.city_name,
       --b.city_name
from cities a,cities b
where a.city_name<>b.city_name;

---------------query to get list of persons working under each employee------

--------------query with inline view in the from clause----------------
select empno,ename,mgr from emp;


select mgr,
       listagg(ename,',') within group(order by ename) emps_list,
       count(*) emps_cnt
from emp
group by mgr
order by mgr;


select empno,
       ename,
       a.mgr,
       nvl(b.emps_list,0) emps_list,
       nvl(b.emps_cnt,0) emps_cnt
from emp a left outer join
         (select mgr,
          listagg(ename,',') within group(order by ename) emps_list,
          count(*) emps_cnt
          from emp
          group by mgr
          order by mgr)b
on a.empno=b.mgr
order by empno;

--------------query with inline view in the select clause----------------

select empno,ename from emp;


select listagg(ename,',') within group(order by ename) emps_list
from emp
where mgr=7566;

select empno,ename,(select listagg(ename,',') within group(order by ename) 
                    from emp
                    where mgr=e.empno) emps_list,
                    (select count(*)
                    from emp
                    where mgr=e.empno) emps_cnt
from emp e
order by empno;


--------------self join--------------
select m.empno,m.ename,
       listagg(e.ename,',') within group(order by e.ename) emp_list,
       count(e.ename) emps_cnt
from emp m left outer join emp e on m.empno=e.mgr
group by m.empno,m.ename
order by m.empno;
-----------------------------end  31-05-2024----------------------------------------------


----01-06-2024  Oracle SQL Practical question Write a sql to replace the comma separated value

create table service (service_code varchar(2),service_name varchar(20));

select * from service;

insert into service values('A','Service-A');
insert into service values('B','Service-B');
insert into service values('C','Service-C');
insert into service values('D','Service-D');
commit;

select * from service;

create table prod_service(prod_code varchar(2),prod_desc varchar(30),service_order varchar(50));

select * from prod_service;


insert into prod_service values('P1','Prod_P1','A,C');
insert into prod_service values('P2','Prod_P2','C,B,D');
insert into prod_service values('P3','Prod_P3','D,A,C,B');
insert into prod_service values('P4','Prod_P4','A,B,C,D');
insert into prod_service values('P5','Prod_P5','D,C,B,A,B');
commit;


select * from prod_service;

select prod_code,prod_desc,service_order,--l,
    --regexp_substr(service_order,'(.*?,){'||(l-1)||'}([^,]*)',1,1,'',2) r_service_code,
    listagg(service.service_name,',') within group(order by l) service_names
    from prod_service,service,
    lateral(select level l from dual connect by level<=regexp_count(service_order,',')+1)
    where service.service_code=regexp_substr(service_order,'(.*?,){'||(l-1)||'}([^,]*)',1,1,'',2)
    group by prod_code,prod_desc,service_order
    order by prod_code;


----query to generate all date ranges for the transactionrecords
select * from daily_trans;

with t1 as
        (
        select trunc(min(tran_date),'MM') tdate, 
        last_day(max(tran_date)) mdate,
        last_day(max(tran_date))-trunc(min(tran_date),'MM')+1 n
        from daily_trans
        ),
t2 as
        (select tdate+level-1 tran_date from t1
        connect by level<=n)
select t2.tran_date,t1.tran_desc,nvl(tran_amount,0) tran_amount
from t2  left outer join daily_trans t1 on t1.tran_date=t2.tran_date
order by t2.tran_date;

--test cases
insert into daily_trans values('01-03-2019','Fee Received',7500);

insert into daily_trans values('21-08-2019','Fee Received',5500);

--------------end 01-06-2024-------------------------------------------


----03-06-2024  Oracle SQL Practical question SQL to Find number of saturday and sunday

with t1 as
        (
        select d,
               trunc(min(d),'MM') startdate,
               last_day(d) lastdate,
               last_day(d)-trunc(min(d),'MM')+1 ndays
        from 
        (
        select to_date('13-05-2025','dd-MM-yyyy') d from dual) a
        ),
t2 as(select startdate+level-1 tdate from t1
connect by level<=ndays)
select --tdate,
to_char(tdate,'day') tday,
count(*) day_count
from t2
where trim(to_char(tdate,'day')) in('saturday','sunday')
group by to_char(tdate,'day');

---Oracle SQL Practical question with answer Write a SQL to print Cricket Dashboard
---performance point of view
select * from cricket;

with t1 as 
        (
        select TEAM_A a, TEAM_B b,
               case when team_a=winner then 1 else 0 end t_a,
               case when team_b=winner then 1 else 0 end t_b
        from cricket),
t2 as (select --a,t_a,b,t_b,r,
       decode(r,1,a,b) teams,
       decode(r,1,t_a,t_b) won_count
from t1,(select rownum r from dual connect by level<=2))
select teams,
       count(won_count) matches_played,
       sum(won_count) matches_won,
       count(won_count)-sum(won_count) matches_lost
       from t2
group by teams;
-----end  03-06-2024----------------------------------

--07-06-2024 Oracle SQL Practical question with answer | SQL to find list of DICE rolled combinations

with t as 
(
select level l from dual connect by level<=6
)
select '('||t1.l || ','||t2.l ||','||t3.l||')' result from t t1,t t2,t t3
where t3.l=t1.l+t2.l;

with t as 
(
select level l from dual connect by level<=6
)
select '('||t1.l || ','||t2.l ||','||t3.l||')' result from t t1,t t2,t t3
where (t3.l=t1.l+t2.l or t2.l=t1.l+t3.l or t1.l=t3.l+t2.l);

---Oracle SQL Practical question with answer | Sort the NUMBERS in the comma separated list
with t as
(
select '3,10,5,1,7,55,75,100,42,12,17' d from dual
),
p as (select --d, 
       regexp_substr(d,'[^,]+',1,level) d1
     from t
     connect by level<=regexp_count(d,',')+1)
select listagg(d1,',') within group(order by to_number(d1)) result from p;

with t as
(
select 'WELCOME'  d from dual
),
p as (select d,
       substr(d,level,1) d1
        from t
        connect by level<=length(d))
select listagg(d1,',') within group(order by d1) result from p;

--end 07-06-2024------------------------------------------------------

--09-06-2024  Oracle SQL Practical question with answer | Reverse the String without using reverse function

with ds as
(
select 'WELCOME' d from dual
)
select reverse(d) result from ds;

with ds as
(
select 'WELCOME' d from dual
),
t1 as (select d,
       substr(d,level,1) d1,
       level l
from ds
connect by level<=length(d))
select --d,d1,l,
       listagg(d1) within group(order by l desc) result
from t1;

---Oracle SQL Practical question with answer | Consolidate two rows as single row
select * from emp_a;--count 11

select * from emp_b;-- count 6

delete from emp_b;

select * from emp_b;--count 0

insert into emp_b
with ds as
(
select empno,ename,rownum,
count(*) over() cnt,
round(count(*) over()/2) rcnt,
round(count(*) over()/2)-rownum reqno
from emp_a),
t1 as(select empno,ename,reqno from ds where reqno>=0),
t2 as (select empno,ename,reqno from ds where reqno<0)
select t1.empno,t1.ename,t2.empno,t2.ename from t1 left outer join t2 on t1.reqno=abs(t2.reqno)
order by 1;

select * from emp_b;

---end  09-06-2024--------------------------------------------

--10-06-2024 Oracle SQL Practical question with answer Fill the missing dates with last not null value

with ds as
(
select min(txn_date) midate,
       max(txn_date) mxdate,
       max(txn_date)-min(txn_date)+1 ndates
from txn_data),
t1 as (select midate+level-1 txn_date from ds
connect by level<=ndates)
select 
t1.txn_date,
--t2.txn_date,
--t2.txn_amount,
last_value(t2.txn_amount ignore nulls) over(order by t1.txn_date) req_txn_amount
from t1 left outer join txn_data t2  on t1.txn_date=t2.txn_date
order by t1.txn_date;

--query to compute start and end value of given sequence
with ds as
(
select 
id,
rownum rno,
id-ROWNUM grpno
from ranges)
select min(id) start_range,max(id) end_range from ds
group by grpno
order by grpno;
-----end 10-06-2023------------------------------------------

--11-06-2024 Oracle SQL Practical question with answer Expand the range to Sequence Numbers
create table ranges2
(
    start_range number,
    end_range number
);

insert into ranges2 values(1,3);
insert into ranges2 values(5,5);
insert into ranges2 values(7,9);
insert into ranges2 values(11,12);
insert into ranges2 values(15,16);
insert into ranges2 values(20,20);
commit;


select t2.r from 
(
select start_range,end_range from ranges_1) t1,
(select rownum r from dual
connect by level<=(select max(end_range) from ranges_1) 
) t2
where t2.r>=t1.start_range and t2.r<=t1.end_range ;

---Second Method


select --start_range,end_range,r-1,
    start_range+r-1 result
    from ranges2,
    lateral(select rownum r from dual connect by level<=end_range-start_range+1);


---Oracle SQL Practical question with answer Grouping The Range Data

create table cars 
(
    name varchar(20),
    start_year number,
    end_year number
);


insert into cars values('Swift',2007,2009);
insert into cars values('Swift',2009,2011);
insert into cars values('Swift',2011,2013);
insert into cars values('Maruthi',2009,2011);
insert into cars values('Maruthi',2013,2015);
commit;


select name,min(req_year) start_year, max(req_year) end_year
    from
    (
select distinct name,--start_year,end_year,r-1,
    start_year+r-1 req_year
    from cars,
     lateral(select rownum r from dual connect by level<=end_year-start_year+1)
order by name,start_year+r-1)
group by name,req_year-rownum;

--end  11-06-2024--------------------------------

----12-06-2024 Oracle SQL Practical question with answer / SQL to check whether given sudoku is resolved


select * from sudoku;

update sudoku set c3=9 where row_no='R3';

commit;

select col_name,col_val col_sum from
        (
        select sum(c1) c1,sum(c2) c2,sum(c3) c3,sum(c4) c4,sum(c5) c5,
        sum(c6) c6,sum(c7) c7,sum(c8) c8,sum(c9) c9 from sudoku
        )
unpivot(col_val for col_name in(c1,c2,c3,c4,c5,c6,c7,c8,c9));
       
select row_no,c1+c2+c3+c4+c5+c6+c7+c8+c9 row_sum from sudoku;

select grp||col_name grp_no,col_val grp_sum from
(
select  'G'||ceil(rownum/3) grp,sum(c1+c2+c3) g1,sum(c4+c5+c6) g2,sum(c7+c8+c9) g3 
from sudoku
group by 'G'||ceil(rownum/3)
order by 1
) unpivot(col_val for col_name in(G1,G2,G3));

--grouping of all the above three select statements rows,cols,grps
select case when sum(distinct col_sum)=45 then 'SUDOKU IS VALID'
       else 'SUDOKU IS INVALID' end Result
from
(
select col_name,col_val col_sum from
        (
        select sum(c1) c1,sum(c2) c2,sum(c3) c3,sum(c4) c4,sum(c5) c5,
        sum(c6) c6,sum(c7) c7,sum(c8) c8,sum(c9) c9 from sudoku
        )
unpivot(col_val for col_name in(c1,c2,c3,c4,c5,c6,c7,c8,c9))
union all
select row_no,c1+c2+c3+c4+c5+c6+c7+c8+c9 row_sum from sudoku
union all
select grp||col_name grp_no,col_val grp_sum from
(
select  'G'||ceil(rownum/3) grp,sum(c1+c2+c3) g1,sum(c4+c5+c6) g2,sum(c7+c8+c9) g3 
from sudoku
group by 'G'||ceil(rownum/3)
order by 1
) unpivot(col_val for col_name in(G1,G2,G3))
);

---Finding where exactly the sudoku puzzle is incorrect
select col_sum val,
       listagg(col_name,',') within group(order by col_name) col_row_grp_names,
       case when sum(distinct col_sum)=45 then 'SUDOKU IS VALID'
       else 'SUDOKU IS INVALID' end Result
from
(
select col_name,col_val col_sum from
        (
        select sum(c1) c1,sum(c2) c2,sum(c3) c3,sum(c4) c4,sum(c5) c5,
        sum(c6) c6,sum(c7) c7,sum(c8) c8,sum(c9) c9 from sudoku
        )
unpivot(col_val for col_name in(c1,c2,c3,c4,c5,c6,c7,c8,c9))
union all
select row_no,c1+c2+c3+c4+c5+c6+c7+c8+c9 row_sum from sudoku
union all
select grp||col_name grp_no,col_val grp_sum from
(
select  'G'||ceil(rownum/3) grp,sum(c1+c2+c3) g1,sum(c4+c5+c6) g2,sum(c7+c8+c9) g3 
from sudoku
group by 'G'||ceil(rownum/3)
order by 1
) unpivot(col_val for col_name in(G1,G2,G3))
)
group by col_sum;

update sudoku set c3=5 where row_no='R3';

commit;

---Oracle SQL Practical question with answer | SQL to convert list of numbers into table format

--x-axis
select c1,c2,c3,c4,c5 from 
(
select level l,
ceil(rownum/5) x,
row_number() over(partition by ceil(rownum/5) order by level) y
from dual
connect by level<=25)
pivot(sum(l) for y in(1 c1,2 c2,3 c3,4 c4,5 c5))
order by 1;

--Y-axis
select c1,c2,c3,c4,c5 from 
(
select level l,
ceil(rownum/5) x,
row_number() over(partition by ceil(rownum/5) order by level) y
from dual
connect by level<=25)
pivot(sum(l) for x in(1 c1,2 c2,3 c3,4 c4,5 c5))
order by 1;

--Using Mod and Ceil Method

with ds as
(
select level d from dual
connect by level<=25
)select --d,
--ceil(d/5),
max(case when mod(d,5)=1 then d end) c1,
max(case when mod(d,5)=2 then d end) c2,
max(case when mod(d,5)=3 then d end) c3,
max(case when mod(d,5)=4 then d end) c4,
max(case when mod(d,5)=0 then d end) c5
from ds
group by ceil(d/5);

--end  12-06-2023---------------------------------------

--13-06-2024 Oracle SQL Practical question | SQL to fetch Emp hierarchical data in Flat format

select EMPNO1, ENAME1, L1, 
       EMPNO2, ENAME2, L2, 
       EMPNO3, ENAME3, L3, 
       EMPNO4, ENAME4, L4, 
       EMPNO empno5, ENAME ename5,
       case when e5.empno is not null then 5 end l5
       from 
(
select EMPNO1, ENAME1, L1, 
       EMPNO2, ENAME2, L2, 
       EMPNO3, ENAME3, L3, 
       EMPNO EMPNO4, ENAME ENAME4,
       case when e4.empno is not null then 4 end l4
       from 
(
select EMPNO1, ENAME1, L1, 
       EMPNO2, ENAME2, L2, 
       EMPNO EMPNO3, ENAME ENAME3,3 L3 from 
(
select e1.EMPNO EMPNO1, e1.ENAME ENAME1, e1.L l1, 
       e2.EMPNO EMPNO2, e2.ENAME ENAME2,2 l2
from (
select empno,ename,1 l from emp e
where mgr is null) e1 left outer join emp e2 on e2.mgr=e1.empno)e2
left outer join emp e3 on e3.mgr=e2.empno2)e3
left outer join emp e4 on e4.mgr=e3.empno3)e4
left outer join emp e5 on e5.mgr=e4.empno4
order by 1,4;

--Second Method
select --empno_lst,ename_lst,
       regexp_substr(empno_lst,'\w+',1,1) empno1,regexp_substr(ename_lst,'\w+',1,1) ename1,1 l1,
       regexp_substr(empno_lst,'\w+',1,2) empno2,regexp_substr(ename_lst,'\w+',1,2) ename2,2 l2,
       regexp_substr(empno_lst,'\w+',1,3) empno3,regexp_substr(ename_lst,'\w+',1,3) ename3,3 l3,
       regexp_substr(empno_lst,'\w+',1,4) empno4,regexp_substr(ename_lst,'\w+',1,4) ename4,
       case when regexp_substr(empno_lst,'\w+',1,4) is not null then 4 end l4,
       regexp_substr(empno_lst,'\w+',1,5) empno5,regexp_substr(ename_lst,'\w+',1,5) ename5,
       case when regexp_substr(empno_lst,'\w+',1,5) is not null then 5 end l5
from
(
select empno,ename,
        trim(',' from sys_connect_by_path(empno,',')) empno_lst,
        trim(',' from sys_connect_by_path(ename,',')) ename_lst,
        CONNECT_BY_ISLEAF is_leaf
from emp
connect by prior empno=mgr
start with mgr is null)
where is_leaf=1
order by 1,4;

--Oracle SQL Practical question | SQL to group the employees into multiple team
--2 members each group
select city,listagg(ename,',') within group(order by ename) empnames,
       'Team-'||row_number() over(order by city) teamname
from 
(
select city,ename,ceil(row_number() over(partition by city order by rownum)/2) grp from emp_city
)
group by city,grp;

--3 members each group
select city,listagg(ename,',') within group(order by ename) empnames,
       'Team-'||row_number() over(order by city) teamname
from 
(
select city,ename,ceil(row_number() over(partition by city order by rownum)/3) grp from emp_city
)
group by city,grp;

--4 members each group
select city,listagg(ename,',') within group(order by ename) empnames,
       'Team-'||row_number() over(order by city) teamname
from 
(
select city,ename,ceil(row_number() over(partition by city order by rownum)/4) grp from emp_city
)
group by city,grp;

---end 13-06-2024--------------------------------------

--14-06-2024  Oracle SQL Practical question | SQL to Get Last three consecutive status count

with ds as
(
select id,rep_month,status,
       decode(status,'red',0,1) flag
from reports
--where id=3
),
t1 as (select id,rep_month,status,flag,
       sum(flag) over(partition by id order by to_date(rep_month,'Mon-yy') desc) sflag
from ds)
select id,count(*) id_count from t1 where sflag=0
group by id
having count(*)>=3;

--Oracle SQL Practical question | SQL to summarize data one row for continuous play of album

with ds as
(
select dt,val,
nvl(lag(val) over(order by dt),val) lval
from values_date
),
t1 as (select dt,
val,
--lval,
--decode(val,lval,0,1) dval,
sum(decode(val,lval,0,1)) over(order by dt) sval
from ds)
select to_char(min(dt),'dd-MON-yy')tdate,val,count(*) val_count from t1
group by val,sval
order by 1;

--end 14-06-2024--------------------------------

--19-06-2024 Oracle SQL Practical question | SQL to fill the missing months with previous months salary

/*
create table empsal
(
ename varchar(50),
mnyr varchar(50),
salary number
)

insert into empsal values('peter','May-19',5000);
insert into empsal values('peter','Aug-19',10000);
insert into empsal values('peter','Mar-20',15000);
insert into empsal values('soloman','Oct-19',20000);
insert into empsal values('soloman','Feb-20',30000);
commit;

select * from empsal;


*/


with ds as
(
select ename,to_date(mnyr,'MM-yy') dt,salary from empsal
),
t1 as 
(select ename,dt,lead(dt,1) over(partition by ename order by dt) nxtdt,salary from ds
order by ename),
t2 as (select ename,
    dt,
    nxtdt,
    salary,
    months_between(nxtdt,dt),
    r-1,
    add_months(dt,r-1) rdt
    from t1,
lateral(select rownum r from dual connect by level<=months_between(nxtdt,dt)))
select ename,to_char(rdt,'Mon-yy') rdt,salary from t2;

--Oracle SQL Practical question | SQL to count number of occurrences of a vowels in a string

with ds
as(
select 'WELCOME' str from dual
)
select str,
       regexp_count(str,'A') A,
       regexp_count(str,'E') E,
       regexp_count(str,'I') I,
       regexp_count(str,'O') O,
       regexp_count(str,'U') U
       
from ds
-- connect by level<=length(str)
;

--second method

with ds
    as
    (select distinct ename from empsal --where ename='peter'
    ),
t1 as (select ename,r,
    upper(substr(ename,r,1)) sename
    from ds,
lateral(select rownum r from dual connect by level<=length(ename)))
select * from 
    (select ename,sename,count(*) cnt from t1 where sename in('A','E','I','O','U')
    group by ename,sename) pivot(max(cnt) for sename in('A','E','I','O','U') );

--end 19-06-2024----------------------------------

---23-06-2024--------
---query to get no of vowels present in the given input
select ename,
       --length(ename) l,
       --replace(upper(ename),'A'), 
       length(ename)-length(replace(upper(ename),'A') ) A,
       length(ename)-length(replace(upper(ename),'E') ) E,
       length(ename)-length(replace(upper(ename),'I') ) I,
       length(ename)-length(replace(upper(ename),'O') ) O,
       length(ename)-length(replace(upper(ename),'U') ) U
from emp_a

---query to ger list of days for a given month
with ds as
(
select 'jan-2024' m from dual
),
ds1 as (select to_date(m,'MON-yy') tdate,
       last_day(to_date(m,'MON-yy')) lday,
       last_day(to_date(m,'MON-yy'))-to_date(m,'MON-yy')+1 ndays
from ds)
select to_char(tdate+level-1,'dd-MON-yyyy') tdate from ds1
connect by level<=ndays;

--end 23-06-2023-----------------------------

--24-06-2024  Oracle SQL Practical question | SQL to convert comma separated string to rows and vice versa

select * from empdept;

select deptno,
       listagg(ename,',') within group(order by ename) empgrp 
from empdept
group by deptno;

/*
create table empgrp
(
    deptno int,
    ename varchar(50)
);

insert into empgrp values(10,'RAGHU,RAJU,RAVI');
insert into empgrp values(20,'MOHAN,PRIYA');
insert into empgrp values(30,'PRAVEEN');
commit;
*/

with ds1 as
    (
    select deptno,ename,
    r
    from empgrp,lateral(select rownum r from dual connect by level<=regexp_count(ename,',')+1)
    )
select deptno,--ename,
    regexp_substr(ename,'\w+',1,r) result
    from ds1;

Oracle SQL Practical question | SQL to compute year end credit card balance

---Query 1
select to_char(tran_date,'Mon-yy') tran_month,
       --tran_amt,
       sum(case when tran_amt>=0 then tran_amt else 0 end) d_amt,
       sum(case when tran_amt<0 then tran_amt else 0 end) c_amt,
       sum(case when tran_amt<0 then 1 else 0 end) cc_cnt,
       case when (sum(case when tran_amt<0 then 1 else 0 end)<3
       or abs(sum(case when tran_amt<0 then tran_amt else 0 end))<100) then -5 else 0
       end fee
from tran_amount
group by to_char(tran_date,'Mon-yy')
order by 1;

---Query 2
select add_months(to_date('jan-20','Mon-yy'),level-1) tran_date,
0 tran_amt       
from dual
connect by level<=12;

--- Query 3 Combining Query from tran_amount and Query 2
select tran_date,tran_amt from tran_amount
union all
select add_months(to_date('jan-20','Mon-yy'),level-1) tran_date,
0 tran_amt       
from dual
connect by level<=12;

--Query 4 Final Combining and doing aggregation from Query1 and Query 3
select --TRAN_MONTH,
sum(D_AMT)+sum(C_AMT)+sum(FEE) result from 
(
select to_char(tran_date,'Mon-yy') tran_month,
       --tran_amt,
       sum(case when tran_amt>=0 then tran_amt else 0 end) d_amt,
       sum(case when tran_amt<0 then tran_amt else 0 end) c_amt,
       sum(case when tran_amt<0 then 1 else 0 end) cc_cnt,
       case when (sum(case when tran_amt<0 then 1 else 0 end)<3
       or abs(sum(case when tran_amt<0 then tran_amt else 0 end))<100) then -5 else 0
       end fee
from (
select tran_date,tran_amt from tran_amount
union all
select add_months(to_date('jan-20','Mon-yy'),level-1) tran_date,
0 tran_amt       
from dual
connect by level<=12
)
group by to_char(tran_date,'Mon-yy')
order by to_date(to_char(tran_date,'Mon-yy'),'Mon-yy')
);

--end 24-06-2024--------------------------------

--25-06-2024  Oracle SQL Practical question | SQL to find the set of rows in hierarchical relational data

select * from ids;

with ds as
        (
        select id from
        (
        select id,old_id,
               CONNECT_BY_ISLEAF lf
        from ids
        connect by prior old_id=id
        start with id=10
        )where lf=1
        )
select id,old_id
from ids
connect by prior id=old_id
start with id=(select id from ds);

---Oracle SQL Practical question | SQL to convert data representation in different format

with ds as
(
select 
       lag(ACTIVATION_DT) over(order by ACTIVATION_DT) p_act_dt,
       lag(DEACTIVATION_DT) over(order by ACTIVATION_DT) p_dact_dt,
       lag(RATE) over(order by ACTIVATION_DT) p_rate,   
       ACTIVATION_DT c_act_dt, DEACTIVATION_DT c_dact_dt, RATE c_rate,
       lead(ACTIVATION_DT) over(order by ACTIVATION_DT) n_act_dt,
       lead(DEACTIVATION_DT) over(order by ACTIVATION_DT) n_dact_dt,
       lead(RATE) over(order by ACTIVATION_DT) n_rate   
from tax_rate),
ds1 as 
(select --P_ACT_DT,
 --P_DACT_DT,
 --P_RATE,
 C_ACT_DT,
 C_DACT_DT,
 C_RATE,
 --N_ACT_DT,
 --N_DACT_DT,
 --N_RATE,
 case when p_act_dt is null or (C_ACT_DT<>P_DACT_DT+1) then 'Added' 
      when C_RATE<>P_RATE then 'Modified' end changes,
 case when N_ACT_DT is null or (C_DACT_DT+1<>N_ACT_DT) then 'Removed' end changes1,
 r
 from ds,(select rownum r from dual connect by level<=2))
 select --C_ACT_DT, C_DACT_DT, C_RATE, CHANGES, CHANGES1, R,
        to_char(decode(r,1,C_ACT_DT,C_DACT_DT),'dd-Mon-yy') dt,
        c_rate rate,
        decode(r,1,changes,changes1) changes
 from ds1
 where decode(r,1,changes,changes1) is not null
 order by decode(r,1,C_ACT_DT,C_DACT_DT);
 --end  25-06-2024--------------------------------------

 --26-06-2024  Oracle SQL Practical question | SQL to convert data representation in different format | METHOD2

with ds as
(
select --p.ACTIVATION_DT p_act_dt, p.DEACTIVATION_DT p_dact_dt, p.RATE p_rate,
       c.ACTIVATION_DT c_act_dt, c.DEACTIVATION_DT c_dact_dt, c.RATE c_rate,
       --n.ACTIVATION_DT n_act_dt, n.DEACTIVATION_DT n_dact_dt, n.RATE n_rate,
       case when p.ACTIVATION_DT is null then 'Added' 
            when c.rate<>p.rate then 'Modified' end Changes1,
       case when n.ACTIVATION_DT is null then 'Removed' end Changes2
from tax_rate c
left outer join tax_rate p on (p.DEACTIVATION_DT+1=c.ACTIVATION_DT)
left outer join tax_rate n on (c.DEACTIVATION_DT+1=n.ACTIVATION_DT))
select to_char(dt,'dd-Mon-yy') dt,rate,change_log from
(
select C_ACT_DT dt, C_RATE rate, CHANGES1 change_log from ds
union all 
select C_DACT_DT, C_RATE, CHANGES2 change_log from ds
) 
where change_log is not null
order by to_date(dt,'dd-MM-yy')
;

---Oracle SQL Practical question | Oracle SQL to check whether two strings are anagram of each other

/*
   create table anagram(sno number,
                 str1 varchar(30) ,
                 str2 varchar(30)
                );
select * from anagram;

insert into anagram values(1,'HEART','EARTH');
insert into anagram values(2,'APPLE','ORANGE');
insert into anagram values(3,'A GENTLEMAN','ELEGANT MAN');
insert into anagram values(4,'SILENT','LISTEN');
insert into anagram values(5,'APPLE','MANGO');
COMMIT;

*/
select sno,str1,str2,--r,
       --substr(str1,r,1) rstr1,
       --substr(str2,r,1) rstr2,
       decode(listagg(substr(str1,r,1)) within group(order by substr(str1,r,1)) ,
       listagg(substr(str2,r,1)) within group(order by substr(str2,r,1)) ,'YES','NO') is_anagram
    from 
    (
select sno,str1,str2,
    --length(str1) l1,
    --length(str2) l2,
    --greatest(length(str1),length(str2)) gt
    r
    from anagram,lateral(select rownum r from dual connect by level<=greatest(length(str1),length(str2))))
    group by sno,str1,str2;
--end  26-06-2023-------------------------------------------------

--27-06-2024  Oracle SQL Practical question | Oracle SQL to divide the rows into groups of data | NTILE function

select GRP_NO, SNO, SNAME, MIN_SNO, MAX_SNO from 
(
select
ntile(3) over(order by sno) grp_no,
sno,
sname,
null min_sno,
null max_sno
from stud
union all
select grp_no,null sno,null sname, min(sno) min_sno,max(sno) max_sno 
from
(
select
ntile(3) over(order by sno) grp_no,
sno,
sname
from stud)
group by grp_no order by grp_no,sno);


select GRP_NO, SNO, SNAME, MIN_SNO, MAX_SNO from 
(
select
ntile(3) over(order by sno) grp_no,
sno,
sname,
null min_sno,
null max_sno
from stud
union all
select grp_no,null sno,null sname, min(sno) min_sno,max(sno) max_sno 
from
(
select
ntile(3) over(order by sno) grp_no,
sno,
sname
from stud)
group by grp_no order by grp_no,sno nulls first);

---Oracle SQL Practical question | Oracle SQL to find total time and work time and break time

with ds as
(
select ENAME, 
       lag(PUNCH_DESC) over(partition by ename order by punch_time) l_punch_desc,
       lag(PUNCH_TIME) over(partition by ename order by punch_time) l_punch_time,
       PUNCH_DESC, PUNCH_TIME
from emp_logins),
t1 as (select ENAME, --L_PUNCH_DESC, L_PUNCH_TIME, 
       PUNCH_DESC, PUNCH_TIME,
       round((case when L_PUNCH_DESC='Punch In' then PUNCH_TIME-L_PUNCH_TIME end)*24,2) w_time,
       round((case when L_PUNCH_DESC='Punch Out' then PUNCH_TIME-L_PUNCH_TIME end)*24,2) b_time
from ds),
t2 as (select ENAME, --PUNCH_DESC, --PUNCH_TIME, 
nvl(W_TIME,0) W_TIME, nvl(B_TIME,0) B_TIME from t1)
select ename,sum(w_time)+sum(b_time) total_time,sum(w_time) work_time,sum(b_time) break_time from t2
group by ename;

---end 27-06-2024---------------------------------------------------------

--28-06-2024  Oracle SQL Practical question | Oracle SQL to compute group number for repeating number

with ds as
(
select c1,c2,
       nvl(lag(c2,1) over(order by c1),0) lc2
from col_t
)
select c1,
       c2,
       --lc2, 
       --decode(c2,lc2,0,1) dc2,
       sum(decode(c2,lc2,0,1)) over(order by c1) grp_no
from ds;

--Oracle SQL Practical question | Oracle SQL to compute count of group of repeating values
--First Method:
alter session set nls_date_format ='dd-MM-yyyy';

with ds as
(
select dt,cd,
       lag(cd,1) over(order by dt),
       decode(cd,lag(cd,1) over(order by dt),0,1) d
from col_values),
t1 as(select dt,cd,d,
       sum(d) over(order by dt) sd
from ds),
t2 as (select distinct cd,sd from t1
order by cd)
select cd,count(*) group_count from t2
group by cd;

-- Query to get Actual count of Code values(Non Distinct Values)

with ds as
(
select dt,cd,
       lag(cd,1) over(order by dt),
       decode(cd,lag(cd,1) over(order by dt),0,1) d
from col_values),
t1 as(select dt,cd,d,
       sum(d) over(order by dt) sd
from ds),
t2 as (select  cd,sd from t1  --removed distinct clause here
order by cd)
select cd,count(*) group_count from t2
group by cd;

--Second Method

with ds as
(
select dt,cd,
       row_number() over(order by dt) rn1,
       row_number() over(partition by cd order by dt) rn2
from col_values
),
t1 as (select dt,cd,rn1-rn2 rn from ds),
t2 as(select distinct cd,rn from t1
order by cd)
select cd,count(*) group_count from t2
group by cd;

-- Query to get Actual count of Code values(Non Distinct Values)

with ds as
(
select dt,cd,
       row_number() over(order by dt) rn1,
       row_number() over(partition by cd order by dt) rn2
from col_values
),
t1 as (select dt,cd,rn1-rn2 rn from ds),
t2 as(select  cd,rn from t1  --Removed distinct clause
order by cd)
select cd,count(*) group_count from t2
group by cd;

----end   28-06-2024--------------------------------------------------

--01-07-2024 Oracle SQL Practical question | Oracle SQL to concatenate previous row value continuously

with ds as
(
select col1,col2,str,instr(str||',',',',1,r) i,r from 
(
select col1,col2,
       listagg(col2,',') within group(order by col2) over(partition by col1) str,
       row_number() over( partition by col1 order by col1) r
from col_test
))
select COL1, COL2, --STR, I,
       substr(str,1,i-1) rstr
from ds;

---Oracle SQL Practical question | Oracle SQL to Find missing number in given range of values

create table serial_tab1
(
name varchar(20),
s_start int,
s_end int
);

insert into serial_tab1 values('Serial_1',1,10);

insert into serial_tab1 values('Serial_2',15,20);

commit;

create table serial_tab2
(
name varchar(20),
val int
);

insert into serial_tab2 values('Serial_1',1);
insert into serial_tab2 values('Serial_1',2);
insert into serial_tab2 values('Serial_1',3);
insert into serial_tab2 values('Serial_1',6);
insert into serial_tab2 values('Serial_1',8);
insert into serial_tab2 values('Serial_1',10);
insert into serial_tab2 values('Serial_2',16);
insert into serial_tab2 values('Serial_2',17);

commit;

select * from serial_tab1;

select * from serial_tab2;

select name,s_start+r-1 val--,s_end,r 
    from serial_tab1,
    lateral(select rownum r from dual connect by level<=s_end-s_start+1)
minus
select name,val from serial_tab2;

---end  01-07-2024-------------------------------